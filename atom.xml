<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>{XFE.js}</title>
  <subtitle>新浪广告前端技术</subtitle>
  <link href="/xfe/atom.xml" rel="self"/>
  
  <link href="http://sinaad.github.io/xfe/"/>
  <updated>2016-02-29T06:10:24.000Z</updated>
  <id>http://sinaad.github.io/xfe/</id>
  
  <author>
    <name>AD-FE Team</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>暂时性死区(TDZ)并不神秘</title>
    <link href="http://sinaad.github.io/xfe/2016/02/26/temporal-dead-zone-tdz-demystified/"/>
    <id>http://sinaad.github.io/xfe/2016/02/26/temporal-dead-zone-tdz-demystified/</id>
    <published>2016-02-26T09:16:19.000Z</published>
    <updated>2016-02-29T06:10:24.000Z</updated>
    
    <content type="html">&lt;p&gt;本文根据 &lt;a href=&quot;http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/&lt;/a&gt; 翻译&lt;/p&gt;
&lt;p&gt;暂时性死区是ECMAScript与作用域相关的一个新语义模块， 在ES2015(又叫ES6)中介绍。&lt;/p&gt;
&lt;p&gt;虽然这个名字听起来有点吓人，但实际上这个概念不难把握。首先，让我们退一步看看ES5中作用域是如何工作的：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&#39;outer scope&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&#39;inner scope&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过执行上面的代码，你能告诉我&lt;code&gt;console.log(x)&lt;/code&gt;打印的是什么么？如果你猜是&lt;code&gt;undefined&lt;/code&gt;, 那么你可以往下继续阅读。否则，你需要花点事件读读关于声明提升（MDN, 足够好的）和变量隐藏相关的内容，这是充分了解TDZ的关键。&lt;/p&gt;
&lt;h2 id=&quot;接触暂时性死区（TDZ）&quot;&gt;&lt;a href=&quot;#接触暂时性死区（TDZ）&quot; class=&quot;headerlink&quot; title=&quot;接触暂时性死区（TDZ）&quot;&gt;&lt;/a&gt;接触暂时性死区（TDZ）&lt;/h2&gt;&lt;p&gt;好的，现在让我们稍微往前一点点，从一个及其简单并且刻意的TDZ作用域的例子开始：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x); &lt;span class=&quot;comment&quot;&gt;// throws a ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&#39;hey&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就像你看到的一样，老的&lt;code&gt;var&lt;/code&gt;和新的&lt;code&gt;let/const&lt;/code&gt;声明（除了他们的作用域外）最大的主要不同点之一就是后者被暂时性死区所约束，也就是他们将抛出&lt;code&gt;ReferenceError&lt;/code&gt;当在初始化之前被访问(读/写), 而不是跟var声明变量一样返回&lt;code&gt;undefined&lt;/code&gt;。这使得代码中的潜在问题更容易被预测和发现，是吧？&lt;/p&gt;
&lt;h2 id=&quot;好吧，TDZ确实没有这么简单&quot;&gt;&lt;a href=&quot;#好吧，TDZ确实没有这么简单&quot; class=&quot;headerlink&quot; title=&quot;好吧，TDZ确实没有这么简单&quot;&gt;&lt;/a&gt;好吧，TDZ确实没有这么简单&lt;/h2&gt;&lt;p&gt;在花点时间看看上面的例子，可以很容易推断&lt;code&gt;let/const&lt;/code&gt;声明并没有被提升，并且这能解释抛出了ReferenceError么？当然不能，这是一种不正确的过于简化的解释（当心一个不明确的资源夺走他）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;估计是不要知其然不知其所以然&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们回到文章最早的那个例子，把var替换成let，看看会发生什么：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&#39;outer scope&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;string&quot;&gt;&#39;inner scope&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你能猜猜&lt;code&gt;console.log(x)&lt;/code&gt;现在会打印出什么么？好吧，实际上，没有结果——这段代码将抛出&lt;code&gt;ReferenceError&lt;/code&gt;因为TDZ的语义。因为&lt;code&gt;let/const&lt;/code&gt;声明提升了，但是当他们在初始化前被访问的时候抛出了错误（而不是跟var一样返回undefined）。我知道前面已经解释过这个事情，但是他真的是TDZ的一个关键点非常值得我重复强调（主要是为了做一些记忆训练——重复这个段落中的重要部分直到他能够深入你的大脑！）&lt;/p&gt;
&lt;p&gt;当然，这仍然有一些过分简化，我已经做了很大的努力来平衡准确性和保持简单，用来创建一个容易记住和理解的概述。现在进入细节…&lt;/p&gt;
&lt;h2 id=&quot;血淋淋的细节&quot;&gt;&lt;a href=&quot;#血淋淋的细节&quot; class=&quot;headerlink&quot; title=&quot;血淋淋的细节&quot;&gt;&lt;/a&gt;血淋淋的细节&lt;/h2&gt;&lt;p&gt;很好奇，是不？接下来让我们来深入探索TDZ。&lt;/p&gt;
&lt;p&gt;ECMAScript2015规范。在一个不规范的note中清晰的解释了let/const声明提升和TDZ语义：&lt;/p&gt;
&lt;h3 id=&quot;13-2-1-Let-和-Const声明&quot;&gt;&lt;a href=&quot;#13-2-1-Let-和-Const声明&quot; class=&quot;headerlink&quot; title=&quot;13.2.1 Let 和 Const声明&quot;&gt;&lt;/a&gt;13.2.1 Let 和 Const声明&lt;/h3&gt;&lt;p&gt;&lt;em&gt;注意&lt;/em&gt; let和const声明定义的变量作用在当前执行上下文的&lt;em&gt;词法环境&lt;/em&gt;中。变量在当他们的词法环境被初始化的时候创建，但是不能被以任何形式反问直到变量的词法绑定被执行。一个变量通过一个词法绑定和一个被赋值的初始化器 A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression当词法绑定被执行的时候，变量通过词法绑定被定义，而不是当变量被创建的时候。如果一个let声明的词法绑定没有初始化器，那么这个变量在初始化绑定被执行的时候会被用&lt;code&gt;undefined&lt;/code&gt;赋值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt; let and const declarations define variables that are scoped to the running execution context’s LexicalEnvironment. The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated. A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value undefined when the LexicalBinding is evaluated.&lt;/p&gt;
&lt;p&gt;如果你对ECMAScript的理解不够透测，我讲用英语再翻译一下相关部分规范：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;变量在当他们的词法环境被初始化的时候创建[…]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这意味着不管控制流何时进入新的作用域(例如：module, function或者块作用域), 所有属于给定的作用域的let/const绑定都会在任何代码执行之前被初始化 —— 换句话说，let/const声明被提升了！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[…]但是不能被以任何形式反问直到变量的词法绑定被执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是TDZ。一个给定的let/const声明绑定不能被以任何形式访问（读/写）知道控制流执行了声明语句 —— 这个跟提升无关，但是跟声明实际在代码中的位置有关。通过例子能简单的解释：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Accessing `x` here before control flow evaluates the `let x` statement&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// would throw a ReferenceError due to TDZ.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// console.log(x);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// From here on, accessing `x` is perfectly fine!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后的部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一个let声明的词法绑定没有初始化器，那么这个变量在初始化绑定被执行的时候会被用&lt;code&gt;undefined&lt;/code&gt;赋值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等价于：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样的，在控制流执行初始化器（或者“隐式” = undefined 的初始化器）之前试图以任何方式访问x都将导致ReferenceError, 当控制流已经执行声明后访问是正常的——在上面两个例子中，在let x声明之后读取x变量都会返回undefined。&lt;/p&gt;
&lt;p&gt;相信现在你已经对TDZ语义有了一个比较好的认识，所以让我们试着做一些稍微高级一点的练习。&lt;/p&gt;
&lt;p&gt;假设有下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = x;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个代码执行的时候会不会有错误？代码执行后x的值是多少？&lt;/p&gt;
&lt;p&gt;首先，记住let/const变量只能被作为已经初始化或者他的初始化器已经被执行——也就是，如果赋值的右边表达式被执行后他的值就被赋值给声明的变量。&lt;/p&gt;
&lt;p&gt;在这中情况下，右边的表达式尝试去读取x变量，但x的初始化器还没有被完全执行——实际上我们在那个点执行——所以x仍然算作为初始化在这个点上并且试图去读取他的值的话会导致一个TDZ的ReferenceError。&lt;/p&gt;
&lt;p&gt;嗯，这里还有一个稍微高级的TDZ的例子——感谢TC39成员和Traceur的维护者Erik Arvindson：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = f();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一行，&lt;code&gt;f()&lt;/code&gt;调用导致了控制流跳转去执行&lt;code&gt;f&lt;/code&gt;方法，他将尝试去读取&lt;code&gt;b&lt;/code&gt;常量，在这个运行时的这个点上，他（b）还没有被初始化(在TDZ中)，因此这将会抛出一个ReferenceError。如你所见，TDZ语义也适用于访问父作用域的变量。&lt;/p&gt;
&lt;h2 id=&quot;TDZ无处不在！&quot;&gt;&lt;a href=&quot;#TDZ无处不在！&quot; class=&quot;headerlink&quot; title=&quot;TDZ无处不在！&quot;&gt;&lt;/a&gt;TDZ无处不在！&lt;/h2&gt;&lt;p&gt;到目前为止，我只是展示了let/const声明的例子，但是TDZ语义实际上在ES2015规范中有很广泛的应用。例如，默认参数也有TDZ语义。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Works fine.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a, b = a&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a === &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b === &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Default parameters are evaluated from left to right,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// so `b` is in the TDZ when `a`&#39;s initializer tries to read it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a = b, b&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;(&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// `a` is still in the TDZ when its own initializer tries to read `a`.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// See the &quot;gory details&quot; section above for more details.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a = a&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;()); &lt;span class=&quot;comment&quot;&gt;// ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可能会疑惑，在下面这种情况下会发生什么：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a = b, b&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a, b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;(&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这个例子看起来可能有点让人困惑，但是他实际上也是一个TDZ反例 —— 因为默认参数在给定函数的父作用域和内部作用域的中间作用域被执行。&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;参数被绑定在这个（中间）作用域并且从左到右被初始化，因此当&lt;code&gt;a&lt;/code&gt;的初始化器试图读取&lt;code&gt;b&lt;/code&gt;的时候，由当前作用域（中间作用域）&lt;code&gt;b&lt;/code&gt;绑定解决的&lt;code&gt;b&lt;/code&gt;标识符在这个时候尚未初始化，这时由于TDZ语义抛出了一个ReferenceError。&lt;/p&gt;
&lt;p&gt;作为另外一个例子，子类（通过&lt;code&gt;class x extends y{}&lt;/code&gt;创建的）的构造器如果在&lt;code&gt;super&lt;/code&gt;构造器调用之前尝试访问&lt;code&gt;this&lt;/code&gt;也会抛出TDZ的ReferenceError。这是因为只要一个子类的构造器还没有调用&lt;code&gt;super()&lt;/code&gt;, 他的this绑定就被认为是为初始化。同样的，如果子类构造器执行到构造器代码的结尾仍然没有调用&lt;code&gt;super()&lt;/code&gt;，这个构造器将（其他任何构造器都一样）隐式地尝试返回this; 当this任然没有初始化的时候会抛出TDZ ReferenceError。&lt;br&gt;引用：&lt;a href=&quot;https://github.com/tc39/ecma262/blob/master/workingdocs/ES6-super-construct%3Dproposal.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ES6 super construct proposal&lt;/a&gt;. （注意，这个建议是写本文两周前提出的，所以他可能从最终的ES2015规范中被改变或者舍弃）&lt;/p&gt;
&lt;h2 id=&quot;TDZ无处不在…除了在转换器或者引擎中&quot;&gt;&lt;a href=&quot;#TDZ无处不在…除了在转换器或者引擎中&quot; class=&quot;headerlink&quot; title=&quot;TDZ无处不在…除了在转换器或者引擎中&quot;&gt;&lt;/a&gt;TDZ无处不在…除了在转换器或者引擎中&lt;/h2&gt;&lt;p&gt;目前，转换器比如像6to5（译者：babel）和Traceur并不会强制任何TDZ语义——Traceur和6to5都有一个开放着的issue，且只是形式上的（译者：这里说的意思可能是这的issue还没有一个很好的解决），6to5试图通过快速的肮脏的静态特征检查来实现但因为算法上的问题导致变量bug不得不立即回退。&lt;br&gt;这里有一些转换器目前无法优先考虑强制TDZ的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;性能&lt;/em&gt;: 标识符 必须有每一个通过运行时监测包装的读/写访问操作用来完全覆盖TDZ语义（见之前“血淋淋的细节”章节中嵌套作用域例子）。这个issue通过有一个可选的TDZ检查变换器运作，只在开发环境中被打开——&lt;br&gt;Performance: identifiers that are covered by the TDZ semantics must have every read/write access operation wrapped by a runtime check in order to fully cover the TDZ semantics (see the nested scope example in the “gory details” section above). This issue can be worked around by having optional TDZ checking transformers that are only enabled in a development environment – this should work fine as long as your code doesn’t expect TDZ ReferenceErrors being thrown in order to work properly (which should be a rare enough use case).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cost/benefit: Implementing proper TDZ checking takes some time and effort that could be spent writing transformers for new features or improving existing ones.&lt;/p&gt;
&lt;p&gt;It is impossible to catch all possible user errors: most transpilers’ goal is to transpile valid ES.next to valid ES.current, so they expect you to know what you’re doing. It would take a nearly infinite amount of time to try to catch all kinds of errors, gibberish and marginal error edge cases that an user can input into a transpiler.&lt;/p&gt;
&lt;p&gt;And as of the time of writing, no browser JavaScript engine has full let declaration spec. compliancy (reference). Firefox Nightly (version 38.0a1 (2015-01-30) at the time of writing) ships with a nice, clean and objective TDZ error message though:&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; x; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ReferenceError: can&#39;t access lexical declaration `x&#39; before initialization&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;This means you must be extra careful when making use of transpilers, as you may be writing code that seems okay right now but that may break any time you update the transpiler to a version which enforces proper TDZ semantics, or when you try to run the code without a transpiling step in an ES2015+ TDZ-compliant environment.&lt;/p&gt;
&lt;h2 id=&quot;And-what-about-var&quot;&gt;&lt;a href=&quot;#And-what-about-var&quot; class=&quot;headerlink&quot; title=&quot;And what about var?&quot;&gt;&lt;/a&gt;And what about var?&lt;/h2&gt;&lt;p&gt;var-declared variables will still behave as they currently do in ES5 – the ECMAScript spec. must always evolve in backwards-compatible ways in order for browser vendors to adopt the new spec. without breaking the web. Theoretically, it could be possible to apply TDZ semantics to var by introducing a new “execution mode” (similar to ‘use strict’), however that is very unlikely to happen seeing as:&lt;/p&gt;
&lt;p&gt;The majority of TC39 opposes adding more execution modes/pragmas/flags.&lt;br&gt;Even if such new execution mode were to be implemented, enforcing TDZ semantics on var-declared variables would introduce an unnecessary entry barrier and refactoring hazards to those who want to port their existing code to the hypothetical new execution mode.&lt;br&gt;Closing words&lt;br&gt;The Temporal Dead Zone semantics can be very useful by providing error feedback to the developer instead of yielding unexpected results (as ES5 code may currently do) in cases where your code may accidentally access uninitialized bindings. Just be aware of these semantics when using a transpiler that does not enforce TDZ, as you may be writing broken code without knowing it.&lt;/p&gt;
&lt;p&gt;Or, just in case you’re really afraid of TDZ – which you shouldn’t be, seeing as most of the time the errors will be clear and easy to fix once transpilers/engines implement the TDZ semantics –, you may as well keep using var for the time being which does not have TDZ semantics. ;)&lt;/p&gt;
&lt;h2 id=&quot;Further-reading&quot;&gt;&lt;a href=&quot;#Further-reading&quot; class=&quot;headerlink&quot; title=&quot;Further reading&quot;&gt;&lt;/a&gt;Further reading&lt;/h2&gt;&lt;p&gt;Temporal Dead Zone explanations by TC39 members Rick Waldron and Allen Wirfs-Brock.&lt;br&gt;let - JavaScript at Mozilla Developer Network.&lt;br&gt;Block-Scoped Declarations - You Don’t Know JS: ES6 &amp;amp; Beyond by Kyle Simpson.&lt;br&gt;ES6 Notes: Default values of parameters by Dmitry Soshnikov.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据 &lt;a href=&quot;http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jsrocks.org/2015/01/t
    
    </summary>
    
      <category term="js" scheme="http://sinaad.github.io/xfe/categories/js/"/>
    
    
      <category term="es6" scheme="http://sinaad.github.io/xfe/tags/es6/"/>
    
      <category term="js" scheme="http://sinaad.github.io/xfe/tags/js/"/>
    
      <category term="tdz" scheme="http://sinaad.github.io/xfe/tags/tdz/"/>
    
      <category term="translate" scheme="http://sinaad.github.io/xfe/tags/translate/"/>
    
  </entry>
  
  <entry>
    <title>ES6介绍：块作用域</title>
    <link href="http://sinaad.github.io/xfe/2016/02/25/es6-block-scoping/"/>
    <id>http://sinaad.github.io/xfe/2016/02/25/es6-block-scoping/</id>
    <published>2016-02-25T10:40:47.000Z</published>
    <updated>2016-02-28T03:08:15.000Z</updated>
    
    <content type="html">&lt;p&gt;本文根据 &lt;a href=&quot;http://dev.venntro.com/2013/09/es6-part-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.venntro.com/2013/09/es6-part-2/&lt;/a&gt; 翻译&lt;/p&gt;
&lt;p&gt;这是介绍即将到来的es6规范特性的系列文章的十个章节中的第二部分。如果你没读过第一部分，读一读可能对你有益。&lt;/p&gt;
&lt;h2 id=&quot;Let声明&quot;&gt;&lt;a href=&quot;#Let声明&quot; class=&quot;headerlink&quot; title=&quot;Let声明&quot;&gt;&lt;/a&gt;Let声明&lt;/h2&gt;&lt;p&gt;在ES5(当前ECMAScript规范的主要版本，他被实现在所有的主流环境中) 中，变量只能被闭包在执行上下文的变量环境中。实际上，这意味着变量（通过var语句声明）是通过他们所在的执行上下文来访问：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;example&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(y); &lt;span class=&quot;comment&quot;&gt;// undefined (not a ReferenceError)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(z); &lt;span class=&quot;comment&quot;&gt;// ReferenceError: z is not defined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; y = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// This declaration is hoisted&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这归结于一个众所周知的概念叫“hoisting（提升）”。当一个函数被调用时，定义绑定初始化算法将函数代码中的每一个变量声明和函数声明以绑定的方式在变量环境中创建。如果你想了解更多关于JavaScript中hoisting的知识，我建议你去读读Ben Cherry的专题文章。&lt;/p&gt;
&lt;p&gt;ES6的变量和函数声明依然有这样的表现（这对于向后兼容是一件好事）。不仅如此，接下来要介绍的let关键字给了我们更多的灵活性：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;example&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(y); &lt;span class=&quot;comment&quot;&gt;// ReferenceError: y is not defined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; y = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过let语句声明的变量被绑定在当前执行上下文的词法环境，而不是在变量环境中。ES6规范对于块语句的一个改变是每一个块都有他自己的词法环境。在上面的例子中，当块（if语句的内容）被执行的时候会创建一个新的词法环境。当let语句被执行的时候会往这个词法环境中添加一个对应的绑定，并且它无法被外部的词法环境（函数声明的这个词法环境）访问到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者：这里应该就是没有hoisting和所谓暂时性死区（TDZ）产生的原因, 这里的描述不够完整，完整的规范描述和分析见本文后面&lt;a href=&quot;#补充说明&quot;&gt;补充说明&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在ES6草案中我们能找到针对块的这个新的词法环境的创建细节：&lt;/p&gt;
&lt;p&gt;Block : { StatementList }&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使oldEnv为当前执行上下文的词法环境。&lt;/li&gt;
&lt;li&gt;使blockEnv为通过传递oldEnv为参数调用&lt;code&gt;NewDeclarativeEnvironment&lt;/code&gt;方法获得的声明式环境记录项&lt;/li&gt;
&lt;li&gt;使用块代码和blockEnv来执行块定义初始化&lt;code&gt;BlockDeclarationInstantiation(code, env）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置执行上下文的词法环境为blockEnv.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;译者：这里两个方法&lt;code&gt;NewDeclarativeEnvironment&lt;/code&gt;和&lt;code&gt;BlockDeclarationInstantiation(code, env）&lt;/code&gt; 传送门 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-newdeclarativeenvironment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-newdeclarativeenvironment&lt;/a&gt; 和 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-blockdeclarationinstantiation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-blockdeclarationinstantiation&lt;/a&gt;&lt;br&gt;&lt;code&gt;NewDeclarativeEnvironment&lt;/code&gt;这个方法简单说就是创建一个新的声明式环境，它的外部环境是传入的oldEnv&lt;br&gt;&lt;code&gt;BlockDeclarationInstantiation(code, env）&lt;/code&gt;这个方法跟本文关系比较密切，见本文后面&lt;a href=&quot;#补充说明&quot;&gt;补充说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;del&gt;这里有个疑问，oldEnv被传递来创建新的blockEnv，那么blockEnv应该是持有外部词法环境，那么查找在上面的TDZ形成的时候查找不到应该去查找外部词法环境就是oldEnv，也就是如果外部声明了某个变量的时候就应该找到而不是报错，这样就没有TDZ的概念了&lt;/del&gt;&lt;br&gt;看另外一个文章，已经没有疑问了，只是规范并不是很正式的说明，也没有具体的实现细节，规范内容见本文后面&lt;a href=&quot;#补充说明&quot;&gt;补充说明&lt;/a&gt;&lt;br&gt;例如：&lt;br&gt;    &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo = &lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;//ReferenceError？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; foo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;值得注意的是let声明不会像var声明一样被提升。试图在let声明被执行之前引用一个标识符会导致错误：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x); &lt;span class=&quot;comment&quot;&gt;// ReferenceError: x is not defined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;任何能使用var声明地方都能使用let声明。特别值得关注的是他在loop初始值化器的使用。当使用var语句作为loop的初始化器时这个声明将被提升变量将被通过他所在的执行上下文访问。这对于那些从实现了块作用域的语言中转过来的新手来说，很容易导致混乱。&lt;br&gt;通过let声明我们能够确保loop的计数器只能被他的块所访问。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i); &lt;span class=&quot;comment&quot;&gt;// Prints 0 to 9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i); &lt;span class=&quot;comment&quot;&gt;// ReferenceError: i is not defined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Const声明&quot;&gt;&lt;a href=&quot;#Const声明&quot; class=&quot;headerlink&quot; title=&quot;Const声明&quot;&gt;&lt;/a&gt;Const声明&lt;/h2&gt;&lt;p&gt;ES6介绍了另外一个声明类型，const(ES6 § 13.2.1). 他有和let一样的块作用域绑定语义,但是他的值是一个只读的常量。不同于let和var声明，他们必须初始化：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x; &lt;span class=&quot;comment&quot;&gt;// x === undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; z; &lt;span class=&quot;comment&quot;&gt;// SyntaxError: const declarations must have an initializer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; y = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// y === 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// SyntaxError: Assignment to constant variable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意const关键字被很多引擎支持有一段时间了，但是在ES6规范中有一些略微的不同。一个主要的差别是常量当前被声明在函数作用域而不是块作用域（不是块作用域么，翻译有问题？）。企图为一个常量赋值会导致失败，但是在所有的引擎中都不会导致报错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者：我觉得const最大的需要注意的地方应该在于对于引用类型，比如对象的const上，这里的应该分歧较多，本文没有提到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;块中的函数声明&quot;&gt;&lt;a href=&quot;#块中的函数声明&quot; class=&quot;headerlink&quot; title=&quot;块中的函数声明&quot;&gt;&lt;/a&gt;块中的函数声明&lt;/h2&gt;&lt;p&gt;ES5中函数声明不允许出现在块中。然而很多实现允许这样，导致了在这些实现中有不同的行为（ES5 §12）：&lt;/p&gt;
&lt;p&gt;目前广泛使用的几种ECMAScript的实现是支持把函数声明作为一个语句的。然而这些实现中对这样函数声明的语法应用上有着重大的，不可调和的差异。&lt;/p&gt;
&lt;p&gt;ES6提议明确允许函数声明出现在块中，也遵守和let，const声明一样的语义：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Do stuff&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    someObj.method = fn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(fn); &lt;span class=&quot;comment&quot;&gt;// ReferenceError: fn is not defined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，这个提议是否可能被实现，依然存在着一些不同的声音，因此我不能确定他是否会被写入最终的规范。如果你对这些疑难的讨论感兴趣，可以去Mozilla和Webkit的issue中看看。&lt;/p&gt;
&lt;p&gt;下节再见，下次我们将看看解构，可能是ES6中最多被谈到的特性之一。follow我们的twitter，在文章发布的时候得到通知，还有别忘了我们正在招聘…&lt;/p&gt;
&lt;h2 id=&quot;补充说明&quot;&gt;&lt;a href=&quot;#补充说明&quot; class=&quot;headerlink&quot; title=&quot;补充说明&quot;&gt;&lt;/a&gt;补充说明&lt;/h2&gt;&lt;h3 id=&quot;ES6-amp-13-2-14-运行时语义：块定义初始化&quot;&gt;&lt;a href=&quot;#ES6-amp-13-2-14-运行时语义：块定义初始化&quot; class=&quot;headerlink&quot; title=&quot;ES6 &amp;amp; 13.2.14 运行时语义：块定义初始化&quot;&gt;&lt;/a&gt;ES6 &amp;amp; 13.2.14 运行时语义：块定义初始化&lt;/h3&gt;&lt;p&gt;&lt;em&gt;注意&lt;/em&gt; 当一个普通块或者Case块内容被执行时，一个新的声明式环境记录被创建并且在这个环境记录项中初始化每一个块作用域的变量，常量，函数，生成器函数，或者块中的类声明的绑定。&lt;/p&gt;
&lt;p&gt;块定义初始化使用code和env为参数，按照下面的方式来执行。code是块对应的内容的语法产生式。env是指绑定被创建的那个声明式环境记录。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使declarations为代码的词法作用域声明&lt;/li&gt;
&lt;li&gt;针对每一个declarations里面的元素d, 执行&lt;ul&gt;
&lt;li&gt;a. 对d的BoundNames里面的每一个元素dn，执行&lt;ul&gt;
&lt;li&gt;i. 如果d的IsConstantDeclaration为true，那么&lt;ol&gt;
&lt;li&gt;使status为env.CreateImmutableBinding(dn, true).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ii. 否则，&lt;ol&gt;
&lt;li&gt;使status为env.CreateMutableBinding(dn, false).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;iii. 断言：status永远不会是一个突然完结&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;b. 如果d是一个GeneratorDeclaration产生式或者FunctionDeclaration产生式, 那么&lt;ul&gt;
&lt;li&gt;i. 使fn为d的BoundNames的唯一元素&lt;/li&gt;
&lt;li&gt;ii. 使fn为为了d使用env为参数执行InstantiateFunctionObject的结果&lt;/li&gt;
&lt;li&gt;iii. 执行env.InitializeBinding(fn, fo).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ES6-amp-13-3-1-Let-and-Const-Declarations&quot;&gt;&lt;a href=&quot;#ES6-amp-13-3-1-Let-and-Const-Declarations&quot; class=&quot;headerlink&quot; title=&quot;ES6 &amp;amp; 13.3.1 Let and Const Declarations&quot;&gt;&lt;/a&gt;ES6 &amp;amp; 13.3.1 Let and Const Declarations&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这是规范中关于暂时性死区TDZ产生的原因的描述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt; let and const declarations define variables that are scoped to the running execution context’s LexicalEnvironment. The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated. A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value undefined when the LexicalBinding is evaluated.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里大概的意思是说，当遇到块语句的时候，就会创建一个新的词法环境，创建后会立即进行块定义初始化来绑定块中的变量（这里很像函数执行环境中的定义绑定初始化过程，也就是其实已经执行了类似的hoisting过程），唯一的差别在于上面的规范规定了在真正执行到let语句的时候（即使已经通过块定义初始化绑定）才能对变量引用进行读/写，这就产生了TDZ，且这也是虽然有定义初始化过程，但没显示出hoisting特性的原因&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据 &lt;a href=&quot;http://dev.venntro.com/2013/09/es6-part-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.venntro.com/2013/09/es6-part-2/&lt;/a&gt; 翻
    
    </summary>
    
      <category term="js" scheme="http://sinaad.github.io/xfe/categories/js/"/>
    
    
      <category term="blockscoping" scheme="http://sinaad.github.io/xfe/tags/blockscoping/"/>
    
      <category term="es6" scheme="http://sinaad.github.io/xfe/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>hexo+mathjax生成公式测试</title>
    <link href="http://sinaad.github.io/xfe/2016/02/19/test/"/>
    <id>http://sinaad.github.io/xfe/2016/02/19/test/</id>
    <published>2016-02-19T08:04:15.000Z</published>
    <updated>2016-02-19T15:13:25.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;公式书写注意&quot;&gt;&lt;a href=&quot;#公式书写注意&quot; class=&quot;headerlink&quot; title=&quot;公式书写注意&quot;&gt;&lt;/a&gt;公式书写注意&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;下标要用转义字符，\_，因为在markdown里面被两个_包围起来的字符会最终被编译成&amp;lt;em&amp;gt;xxx&amp;lt;\/em&amp;gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;举例&quot;&gt;&lt;a href=&quot;#举例&quot; class=&quot;headerlink&quot; title=&quot;举例&quot;&gt;&lt;/a&gt;举例&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$$\frac&amp;#123;\partial u&amp;#125;&amp;#123;\partial t&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= h^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; \left( \frac&amp;#123;\partial^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; u&amp;#125;&amp;#123;\partial x^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\frac&amp;#123;\partial^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; u&amp;#125;&amp;#123;\partial y^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\frac&amp;#123;\partial^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; u&amp;#125;&amp;#123;\partial z^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;\right)$$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;$$\frac{\partial u}{\partial t}&lt;br&gt;= h^2 \left( \frac{\partial^2 u}{\partial x^2} +&lt;br&gt;\frac{\partial^2 u}{\partial y^2} +&lt;br&gt;\frac{\partial^2 u}{\partial z^2}\right)$$&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\mathcal&amp;#123;L&amp;#125;(x,\beta) = \sum_&amp;#123;i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;^&amp;#123;m&amp;#125; \mathcal&amp;#123;L&amp;#125;\_i(x\_i, \beta) = \sum_&amp;#123;i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;^&amp;#123;m&amp;#125; \left(f\_i(x\_i) + \beta^T A\_i x\_i - \frac&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&amp;#123;N&amp;#125; \beta^T b \right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\qquad(&lt;span class=&quot;number&quot;&gt;1.7&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;$$&lt;br&gt;\mathcal{L}(x,\beta) = \sum_{i=1}^{m} \mathcal{L}_i(x_i, \beta) = \sum_{i=1}^{m} \left(f_i(x_i) + \beta^T A_i x_i - \frac{1}{N} \beta^T b \right)&lt;br&gt;\qquad(1.7)&lt;br&gt;$$&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\begin&amp;#123;align&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;amp; \min_&amp;#123;x&amp;#125; \quad f(x) \\\\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;amp; s.t. \; Ax=b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\end&amp;#123;align&amp;#125;  \qquad(&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;$$&lt;br&gt;\begin{align}&lt;br&gt;&amp;amp; \min_{x} \quad f(x) \\&lt;br&gt;&amp;amp; s.t. \; Ax=b&lt;br&gt;\end{align}  \qquad(1.1)&lt;br&gt;$$&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \mathcal&amp;#123;L&amp;#125;(x,\beta) = f(x) + \beta^T (Ax-b) \qquad(&lt;span class=&quot;number&quot;&gt;1.2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$$&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;$$&lt;br&gt;    \mathcal{L}(x,\beta) = f(x) + \beta^T (Ax-b) \qquad(1.2)&lt;br&gt;$$&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;公式书写注意&quot;&gt;&lt;a href=&quot;#公式书写注意&quot; class=&quot;headerlink&quot; title=&quot;公式书写注意&quot;&gt;&lt;/a&gt;公式书写注意&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;下标要用转义字符，\_，因为在markdown里面被两个_包围起来的字符会最终被编译成&amp;lt;e
    
    </summary>
    
      <category term="other" scheme="http://sinaad.github.io/xfe/categories/other/"/>
    
    
      <category term="algo" scheme="http://sinaad.github.io/xfe/tags/algo/"/>
    
      <category term="hexo-math" scheme="http://sinaad.github.io/xfe/tags/hexo-math/"/>
    
      <category term="latex" scheme="http://sinaad.github.io/xfe/tags/latex/"/>
    
      <category term="mathjax" scheme="http://sinaad.github.io/xfe/tags/mathjax/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo和github创建团队博客</title>
    <link href="http://sinaad.github.io/xfe/2016/02/18/create-team-blog-with-hexo-and-github/"/>
    <id>http://sinaad.github.io/xfe/2016/02/18/create-team-blog-with-hexo-and-github/</id>
    <published>2016-02-18T14:07:44.000Z</published>
    <updated>2016-02-26T07:38:06.000Z</updated>
    
    <content type="html">&lt;p&gt;为了沉淀团队技术分享，所以最近需要创建一个前端团队博客，确定了下面几个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费自由的空间，同时正好利用之前创建sinaad这个github组织，所以选用&lt;code&gt;github&lt;/code&gt;作为承载空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;markdown&lt;/code&gt;是一种对码农来说比较自然的写博文的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;找了一圈后，确定jeklly或者hexo，jeklly通过gem安装，hexo使用nodejs安装，基于前端对nodejs的熟悉，最后选用了hexo。&lt;/p&gt;
&lt;h2 id=&quot;hexo&quot;&gt;&lt;a href=&quot;#hexo&quot; class=&quot;headerlink&quot; title=&quot;hexo&quot;&gt;&lt;/a&gt;hexo&lt;/h2&gt;&lt;p&gt;了解hexo，请戳：&lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hexo.io&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;你需要先安装一个node， 请戳：&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完成后在命令行中输入&lt;code&gt;node -v&lt;/code&gt;， 出现如下类似版本号说明安装成功，新版本的node都自带npm（node package manager node的包管理工具，后续的hexo通过npm安装）&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;node -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v5.&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;hexo安装和使用&quot;&gt;&lt;a href=&quot;#hexo安装和使用&quot; class=&quot;headerlink&quot; title=&quot;hexo安装和使用&quot;&gt;&lt;/a&gt;hexo安装和使用&lt;/h2&gt;&lt;h3 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等待安装完成&lt;/p&gt;
&lt;h3 id=&quot;初始化hexo项目&quot;&gt;&lt;a href=&quot;#初始化hexo项目&quot; class=&quot;headerlink&quot; title=&quot;初始化hexo项目&quot;&gt;&lt;/a&gt;初始化hexo项目&lt;/h3&gt;&lt;p&gt;进入你将要存放本地blog repo的目录，创建一个hexo初始项目，如xfe到当前目录&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; some-dir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init xfe&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等待初始化结束&lt;/p&gt;
&lt;h3 id=&quot;创建一篇文章&quot;&gt;&lt;a href=&quot;#创建一篇文章&quot; class=&quot;headerlink&quot; title=&quot;创建一篇文章&quot;&gt;&lt;/a&gt;创建一篇文章&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; xfe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new post-file-name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#hexo n&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;成功后会在xfe目录的source/_posts下自动创建一个post-file-name.md文件&lt;/p&gt;
&lt;p&gt;接下来用markdown编辑这个文档，用心写好你的文章，保存&lt;/p&gt;
&lt;h3 id=&quot;编译文章&quot;&gt;&lt;a href=&quot;#编译文章&quot; class=&quot;headerlink&quot; title=&quot;编译文章&quot;&gt;&lt;/a&gt;编译文章&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#hexo g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;本地查看文章效果&quot;&gt;&lt;a href=&quot;#本地查看文章效果&quot; class=&quot;headerlink&quot; title=&quot;本地查看文章效果&quot;&gt;&lt;/a&gt;本地查看文章效果&lt;/h3&gt;&lt;p&gt;hexo提供了一个本地server能够在本地启动一个静态服务器查看文章效果&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#或者使用hexo s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认在4000端口启动，当然你也可以通过xfe根目录下的_config.yml文件进行配置（_config.yml有很多高级配置，可以自行查看hexo的文档了解～）&lt;/p&gt;
&lt;p&gt;启动后在浏览器上通过&lt;a href=&quot;http://localhost:4000即可访问&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000即可访问&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;发布到github&quot;&gt;&lt;a href=&quot;#发布到github&quot; class=&quot;headerlink&quot; title=&quot;发布到github&quot;&gt;&lt;/a&gt;发布到github&lt;/h2&gt;&lt;p&gt;在发布到github前你需要先了解下github的gh-pages相关分支，这里我就不赘述了，搜索一下就清楚了&lt;br&gt;大致是你在github上申请的一个repo，经过简单的设置，gh-pages分支可以被自动发布成静态站点，之后可以通过reponame.github.io访问这个站点，当然你也可以自己申请一个域名，cname到这个上面来&lt;/p&gt;
&lt;p&gt;好了，假装我已经自动配置完成了一个gh-pages，他的repo地址为&lt;a href=&quot;https://github.com/sinaad/xfe.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/sinaad/xfe.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从前面的步骤，我得到了一个hexo初始化好的xfe目录，接下来，需要把它变成一个git repo，通过下面的命令&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; xfe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后添加远程push跟pull的地址， 把这个本地仓库跟远程github上的repo关联&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin https://github.com/sinaad/xfe.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，你需要吧xfe文件夹的内容推送到remote的gh-pages分支上去， 这里需要用到强制推送，否则你就先pull一下在push&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 提交&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git ci -m &lt;span class=&quot;string&quot;&gt;&quot;first commit&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建并切换到本地gh-pages分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git co -b gh-pages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 强制提交gh-pages分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push &lt;span class=&quot;operator&quot;&gt;-f&lt;/span&gt; origin gh-pages&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果提交成功了，就可以通过&lt;a href=&quot;http://sinaad.github.io/xfe进行访问了，&quot;&gt;http://sinaad.github.io/xfe进行访问了，&lt;/a&gt; 打工告成！！！&lt;/p&gt;
&lt;h3 id=&quot;其他方法&quot;&gt;&lt;a href=&quot;#其他方法&quot; class=&quot;headerlink&quot; title=&quot;其他方法&quot;&gt;&lt;/a&gt;其他方法&lt;/h3&gt;&lt;p&gt;上面描述了一种先通过hexo初始化项目，后关联github的方式来创建，当然你也可以先申请repo，然后通过&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/sinaad/xfe.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;来创建这个xfe目录，并拉取gh-pages分支&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git co -b gh-pages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull origin gh-pages&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在进入xfe目录，使用hexo init/new来初始化并创建文章，最后在push到gh-pages中的步骤来完成&lt;/p&gt;
&lt;h2 id=&quot;真相&quot;&gt;&lt;a href=&quot;#真相&quot; class=&quot;headerlink&quot; title=&quot;真相&quot;&gt;&lt;/a&gt;真相&lt;/h2&gt;&lt;p&gt;其实，上面所说的关联github的方法主要是我想让你熟悉下git的一些操作，hexo已经贴心的提供了一个很简单的工具进行关联repo（hexo deploy命令）&lt;/p&gt;
&lt;p&gt;你只要通过下面几步：&lt;/p&gt;
&lt;p&gt;1.安装hexo-deployer-git插件&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-git --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.配置远程git repo地址和deploy的方式&lt;/p&gt;
&lt;p&gt;找到根目录下的_config.yml文件，找到并配置下面的内容&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Deployment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## Docs: https://hexo.io/docs/deployment.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repository: https://github.com/sinaad/xfe.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: gh-pages&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3、编译并使用&lt;code&gt;hexo deploy&lt;/code&gt;命令进行发布&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#hexo g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#hexo d&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大功告成，请不要打脸..&lt;/p&gt;
&lt;h2 id=&quot;如何贡献文章&quot;&gt;&lt;a href=&quot;#如何贡献文章&quot; class=&quot;headerlink&quot; title=&quot;如何贡献文章　&quot;&gt;&lt;/a&gt;如何贡献文章　&lt;/h2&gt;&lt;p&gt;如果已经有了初始化好的hexo的git repo，你要贡献文章，那么你只需要按照下面的步骤来做：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据第一部分的要求安装好node和hexo&lt;/li&gt;
&lt;li&gt;检出&lt;a href=&quot;https://github.com/sinaad/xfe.git的gh-pages分支&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/sinaad/xfe.git的gh-pages分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;为了更好的审核文章质量，请在检出的gh-pages分支上创建一个你自己的名字命名的分支&lt;/li&gt;
&lt;li&gt;通过hexo new的步骤创建文章并完成文章的编写，并提交到自己的分支&lt;/li&gt;
&lt;li&gt;通知相关技术组成员进行文章审核&lt;/li&gt;
&lt;li&gt;审核通过后由相关负责人进行合并到gh-pages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;感谢对知识的无私贡献&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;其实没什么好总结的，&lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hexo.io&lt;/a&gt; 上都写的很清楚，hexo还提供了各种丰富的风格包可以简单安装，你还可以自己看看然后个性化你的blog&lt;/p&gt;
&lt;p&gt;最后，欢迎关注 &lt;a href=&quot;https://sinaad.github.io/xfe&quot;&gt;https://sinaad.github.io/xfe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;h3 id=&quot;配置多说评论框&quot;&gt;&lt;a href=&quot;#配置多说评论框&quot; class=&quot;headerlink&quot; title=&quot;配置多说评论框&quot;&gt;&lt;/a&gt;配置多说评论框&lt;/h3&gt;&lt;p&gt;国内，多说算是比较好的一个评论管理平台，hexo也能很简单的集成多说&lt;br&gt;1、访问 &lt;a href=&quot;http://duoshuo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://duoshuo.com/&lt;/a&gt; ，点我要安装，按步骤填写&lt;br&gt;2、找到多说域名前面你填入的那个子域名，比如sinaad-xfe&lt;br&gt;3、配置_config.yml文件&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Duoshuo ShortName&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;duoshuo_shortname: sinaad-xfe&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置tags&quot;&gt;&lt;a href=&quot;#配置tags&quot; class=&quot;headerlink&quot; title=&quot;配置tags&quot;&gt;&lt;/a&gt;配置tags&lt;/h3&gt;&lt;p&gt;根据上面的步骤完成后，点击tags是404的页面，需要通过下面的步骤来配置&lt;/p&gt;
&lt;p&gt;1、通过命令生成tags页面&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo new page &lt;span class=&quot;string&quot;&gt;&quot;tags&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2、编辑生成的tags页面source/tags/index.md&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: Tagcloud&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;02&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;: tags&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;comments: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、在新建的文章开头添加tags: [tag1,tag2,tag3], 类似格式即可&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: 当前端也拥有 Server 的能力&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;02&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: [js,server,ServiceWorker]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4、如果tags为中文，为了避免路径中出现中文，可以在_config.yml中配置tags的map&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Category &amp;amp; Tag&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    服务端: server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    前端: fe&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;配置categories&quot;&gt;&lt;a href=&quot;#配置categories&quot; class=&quot;headerlink&quot; title=&quot;配置categories&quot;&gt;&lt;/a&gt;配置categories&lt;/h3&gt;&lt;p&gt;同tags, 把tags改成categories即可&lt;/p&gt;
&lt;h3 id=&quot;部署的不是xxx-github-com-目录而是某个子目录xxx-github-com-xfe的情况&quot;&gt;&lt;a href=&quot;#部署的不是xxx-github-com-目录而是某个子目录xxx-github-com-xfe的情况&quot; class=&quot;headerlink&quot; title=&quot;部署的不是xxx.github.com/目录而是某个子目录xxx.github.com/xfe的情况&quot;&gt;&lt;/a&gt;部署的不是xxx.github.com/目录而是某个子目录xxx.github.com/xfe的情况&lt;/h3&gt;&lt;p&gt;修改_config.yml中的配置&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# URL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url: http://sinaad.github.io/xfe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root: /xfe/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink: :year/:month/:day/:title/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink_defaults:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;增加rss功能&quot;&gt;&lt;a href=&quot;#增加rss功能&quot; class=&quot;headerlink&quot; title=&quot;增加rss功能&quot;&gt;&lt;/a&gt;增加rss功能&lt;/h3&gt;&lt;p&gt;1、安装对应的feed插件&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2、配置_config.yml，按如下配置：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Set rss to false to disable feed link.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Leave rss as empty to use site&#39;s feed link.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Set rss to specific value if you have burned your feed already.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rss: atom.xml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、从新部署文件&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#这里不是故意写两遍，当你遇到首页只有一篇文章摘要的时候，执行两边能解决问题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;欢迎评论补充你遇到的问题～&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;为了沉淀团队技术分享，所以最近需要创建一个前端团队博客，确定了下面几个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费自由的空间，同时正好利用之前创建sinaad这个github组织，所以选用&lt;code&gt;github&lt;/code&gt;作为承载空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;markd
    
    </summary>
    
      <category term="other" scheme="http://sinaad.github.io/xfe/categories/other/"/>
    
    
      <category term="blog" scheme="http://sinaad.github.io/xfe/tags/blog/"/>
    
      <category term="github" scheme="http://sinaad.github.io/xfe/tags/github/"/>
    
      <category term="hexo" scheme="http://sinaad.github.io/xfe/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>当前端也拥有 Server 的能力</title>
    <link href="http://sinaad.github.io/xfe/2016/02/18/when-fe-has-the-power-of-server/"/>
    <id>http://sinaad.github.io/xfe/2016/02/18/when-fe-has-the-power-of-server/</id>
    <published>2016-02-18T08:29:25.000Z</published>
    <updated>2016-02-26T07:58:48.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.barretlee.com/blog/2016/02/16/when-fe-has-the-power-of-server/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.barretlee.com/blog/2016/02/16/when-fe-has-the-power-of-server/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天看了不少文章，比较感兴趣的是 Cache API。它是浏览器 Request/Response 的缓存管理工具，其使用风格和运用场景让我瞬间联想到了 ServiceWorker 和 Fetch API，相信很多同学也多次看到过这两个东西，本文会对它们做一个简洁的介绍，并谈一谈我对这些新玩具的看法。&lt;/p&gt;
&lt;h3 id=&quot;Fetch-API&quot;&gt;&lt;a href=&quot;#Fetch-API&quot; class=&quot;headerlink&quot; title=&quot;Fetch API&quot;&gt;&lt;/a&gt;Fetch API&lt;/h3&gt;&lt;p&gt;传统的 XMLHttpRequest，出了两个版本，在 XHR2.0 中引入了跨源请求、上传进度事件和对二进制数据的支持等，这些 API 的增强让 AJAX 可以很方便地与 HTML5 API 相结合，例如 File System API、Web Audio API、WebGL 等，让前端对音视频的处理和富客户端元素的处理更加有亲和力。&lt;br&gt;作为一个与后端交互的通道，XHR2.0 的接口封装依然过于底层。看看 jQuery 对 AJAX 的封装，再回头看看我们今天要介绍的 Fetch API，不得不惊叹，浏览器已经在应用层面思考着功能的拓展，依托着 Promise 产出了十分友好的新一套接口。&lt;br&gt;以前我们使用 XHR 去请求一个资源，会这么做：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Just getting XHR is a mess!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.XMLHttpRequest) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XMLHttpRequest();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.ActiveXObject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ActiveXObject(&lt;span class=&quot;string&quot;&gt;&#39;Msxml2.XMLHTTP&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ActiveXObject(&lt;span class=&quot;string&quot;&gt;&#39;Microsoft.XMLHTTP&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.onreadstatechange = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// handle data;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.open(&lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;http://barretlee.com/test.json&#39;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.send(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而使用 Fetch API，我们只需要：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;http://barretlee.com/test.json&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Convert to JSON&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.json();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(val); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于 Text/HTML 和 Blob 等格式的请求和转化也是异常方便：我要说话&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Text/HTML 请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;/next/page&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.text();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;text&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(text); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Blob 流&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;flowers.jpg&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.blob();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;blob&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;string&quot;&gt;&#39;img&#39;&lt;/span&gt;).src = URL.createObjectURL(blob);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Fetch API 让我们更加关注请求和响应之间的交互，而不是聚焦在如何请求和如何处理响应两个问题上。&lt;/p&gt;
&lt;p&gt;当然，它也存在几个相比 XHR 不足的地方，首先它不能 abort 请求，同时也不能获取请求过程中的 progress 状态，当然也没有 timeout 超时处理。Fetch API 是基于 Promise 的，而 Promise 的状态只有 pending、resolve、reject，不会出现诸如 pending(80%) 的状态提示；我们也无法对一个 Promise chains 做 abort 处理，这些都是能够理解并且接受的。&lt;/p&gt;
&lt;p&gt;我也相信，Fetch API 有能力提供这些状态信息和附加的 API，只是在这个不成熟的环境下，它目前不需要迈这么大的步子。&lt;/p&gt;
&lt;h3 id=&quot;ServiceWorker&quot;&gt;&lt;a href=&quot;#ServiceWorker&quot; class=&quot;headerlink&quot; title=&quot;ServiceWorker&quot;&gt;&lt;/a&gt;ServiceWorker&lt;/h3&gt;&lt;p&gt;ServiceWorker，简单而言就是一个放在前端的 HTTP 拦截器，比如我们要请求一个不存在的 URI 如：/test/a.html，直接请求就会响应 404，而如果我们预先在 ServiceWorker 中注册了这个地址，并且指定响应内容，当再次请求时，你会看到结果是存在的，举个例子：我要说话&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;!—demo.html—&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;navigator.serviceWorker.register(&quot;worker.js&quot;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  scope: ”/test/a.html&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fetch(‘/test/a.html’).then(function(response) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return response.text();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;).then(function(text) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(text); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 demo.html 文件中，我们看到，将 /test/a.html 的请求交给 worker.js 来处理，处理方式为：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// workker.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addEventListener(&lt;span class=&quot;string&quot;&gt;&quot;fetch&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;evt&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  evt.respondWith(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Response(“Hi, Barret Lee”));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 demo.html 的回调中使用 Fetch 获取/test/a.html 这个并不存在的内容，被 ServiceWorker 捕获，交给 worker.js 处理并响应 Hi, Barret Lee 的文本，整个设计思路十分清晰，很轻松地拦截了来自客户端的请求，并作出了响应。&lt;/p&gt;
&lt;p&gt;由于 ServiceWorker 是对 Promise 友好的，响应时也可以模拟服务器休眠状态：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;addEventListener(&lt;span class=&quot;string&quot;&gt;&quot;fetch&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;evt&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  evt.respondWith(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resolve(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Response(“Hi, Barret Lee”));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于 Fetch API 提供了对 Header 头的修改，我们几乎可以利用 ServiceWorker 实现真实 HTTP Server 的基本功能。&lt;/p&gt;
&lt;p&gt;ServiceWorker 一定程度上改变了 Web 协作的交互模式，传统情况下，我们需要开启一个 Web Server，或者让其他人提供 HTTP Server，前后端之间交互，沟通成本比较高。而 ServiceWorker 把 HTTP Server 搬到了客户端，我们可以在浏览器上轻松 Hold 住两端的操作。这也算是 Web 技术栈融合的表现吧。&lt;/p&gt;
&lt;p&gt;当我们的目光放在 HTTP 的交互上，ServiceWorker 会有无限的想象空间，比如对 History API 的延伸思考，跨页面共享问题，前端请求合并和分拆问题，mock 数据问题，前后端的联调问题，类 graphQL 问题，数据的缓存更新和复用问题等等。&lt;/p&gt;
&lt;h3 id=&quot;Cache-API&quot;&gt;&lt;a href=&quot;#Cache-API&quot; class=&quot;headerlink&quot; title=&quot;Cache API&quot;&gt;&lt;/a&gt;Cache API&lt;/h3&gt;&lt;p&gt;Cache API，简而言之就是一个 Request/Response 的缓存对象组，它的生命周期跟 ServiceWorker 是紧密相连的，它没有失效时间，不删除就会一直保持原样。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;caches.open(&lt;span class=&quot;string&quot;&gt;&#39;test-cache&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cache&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cache.add(&lt;span class=&quot;string&quot;&gt;&#39;/index.html&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个简单的操作，就将 /index.html 这个页面缓存了下来，如果你使用的是最新版的 Chrome，可以打开 DevTools &amp;gt; Resources &amp;gt; Cache Storage，多了一个 test-cache 的缓存表，表中多出一项，Request 为 &lt;a href=&quot;http://barretlee.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://barretlee.com/index.html&lt;/a&gt;, Response 为 OK。如下方式可以查看缓存内容：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;caches.open(&lt;span class=&quot;string&quot;&gt;&#39;test-cache&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cache&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cache.keys().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cachedRequests&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(cachedRequests);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当浏览器处于 idle（空闲） 状态的时候，会将 Cache 资源预加载到本地。这也让我想起了 link 标签中有一个 prefetch 功能，也会有同学想到 Manifest，不过这两个东西都是不能友好控制的，而 Cache 给我们带来了这样的便利。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h3&gt;&lt;p&gt;我一直相当看好 Fetch API 系列相关的新接口，它的特点也很清晰，首先是基于 Promise 的实现，这个实现解决了回调和状态控制的问题，然后是提供了应用级别的接口访问，现在可以把一个 HTTP 请求作为可控的对象随意操作，无论是 Request 还是 Response 都在我们的掌握之中，同时也一定程度解决了跨页面资源共享的问题（至于跨页面通讯，我们有 postMessage 和 MessageChannel 等工具）。&lt;/p&gt;
&lt;p&gt;目前浏览器对 Fetch API 和 ServiceWorker 的支持都是比较可观的，虽然 W3C 上的文档状态还是 Draft 模式，相信随着我们对业务需求的更加明确，对前端认知的的不断深入，这些东西将很快被定为 RFC。&lt;/p&gt;
&lt;p&gt;本文没有对 API 的使用做深入的说明，一方面是因为这些东西能在 Google 上找到，其次，我觉得有些 API 的设计上还不够成熟，今后会有增删，感兴趣的同学可以去 W3C 提供的文档中深入学习下。&lt;/p&gt;
&lt;h3 id=&quot;拓展阅读&quot;&gt;&lt;a href=&quot;#拓展阅读&quot; class=&quot;headerlink&quot; title=&quot;拓展阅读&quot;&gt;&lt;/a&gt;拓展阅读&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/file/xhr2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.html5rocks.com/zh/tutorials/file/xhr2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.web-tinker.com/article/20882.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.web-tinker.com/article/20882.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://davidwalsh.name/fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://davidwalsh.name/fetch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Cache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Cache&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.barretlee.com/blog/2016/02/16/when-fe-has-the-power-of-server/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http
    
    </summary>
    
      <category term="share" scheme="http://sinaad.github.io/xfe/categories/share/"/>
    
    
      <category term="ServiceWorker" scheme="http://sinaad.github.io/xfe/tags/ServiceWorker/"/>
    
      <category term="js" scheme="http://sinaad.github.io/xfe/tags/js/"/>
    
      <category term="server" scheme="http://sinaad.github.io/xfe/tags/server/"/>
    
  </entry>
  
</feed>
