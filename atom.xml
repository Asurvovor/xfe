<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>{XFE.js}</title>
  <subtitle>新浪广告前端技术</subtitle>
  <link href="/xfe/atom.xml" rel="self"/>
  
  <link href="http://sinaad.github.io/xfe/"/>
  <updated>2016-02-19T09:31:02.000Z</updated>
  <id>http://sinaad.github.io/xfe/</id>
  
  <author>
    <name>AD-FE Team</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ADMM调研-v0.1（测试公式）</title>
    <link href="http://sinaad.github.io/xfe/2016/02/19/test/"/>
    <id>http://sinaad.github.io/xfe/2016/02/19/test/</id>
    <published>2016-02-19T08:04:15.000Z</published>
    <updated>2016-02-19T09:31:02.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-约束优化问题一般解决方案&quot;&gt;&lt;a href=&quot;#1-约束优化问题一般解决方案&quot; class=&quot;headerlink&quot; title=&quot;1. 约束优化问题一般解决方案&quot;&gt;&lt;/a&gt;1. 约束优化问题一般解决方案&lt;/h3&gt;&lt;h4 id=&quot;1-1-Dual-Ascent（对偶上升法）&quot;&gt;&lt;a href=&quot;#1-1-Dual-Ascent（对偶上升法）&quot; class=&quot;headerlink&quot; title=&quot;1.1. Dual Ascent（对偶上升法）&quot;&gt;&lt;/a&gt;1.1. &lt;strong&gt;Dual Ascent（对偶上升法）&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;对于凸函数的优化问题，对偶上升法对偶上升法核心思想就是引入一个对偶变量，然后利用交替优化的思路，使得两者同时达到optimal。&lt;/p&gt;
&lt;p&gt;一个典型的等式约束最优化问题，形式化表示如下：&lt;/p&gt;
&lt;span&gt;$$\begin{align*}
&amp;amp; \min_{x} \quad f(x) \\
&amp;amp; s.t. \; Ax=b
\end{align*}        \qquad(1.1)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;p&gt;目标函数是\(f(x)\)，\(x=(x_1,x_2,\cdots,x_n)^T \in R^n\) （\(n\)表示参数向量个数）；下面是等式约束。&lt;/p&gt;
&lt;p&gt;引入拉格朗日乘子（又称算子），这里用\(\beta\)表示乘子，得到的拉格朗日公式为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;    \mathcal{L}(x,\beta) = f(x) + \beta^T (Ax-b) \qquad(1.2)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;对偶函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;    g(\beta) = \inf_{x} L(x,\beta) \qquad(1.3)&lt;br&gt;    $$&lt;/p&gt;
&lt;p&gt;在强对偶性假设下，即最小化原凸函数（primal）等价于最大化对偶函数（dual），两者会同时达到optimal。可得：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;    x^{&lt;em&gt;} = \arg \min_{x} \mathcal{L}(x, y^{&lt;/em&gt;})  \qquad(1.4)&lt;br&gt;    $$&lt;/p&gt;
&lt;p&gt;如果对偶函数\(g(\beta)\)可导，使用Dual Ascent法，交替更新参数，使得同时收敛到最优。迭代公式如下：&lt;/p&gt;
&lt;span&gt;$$\begin{align*}
x^{k+1} &amp;amp; := \arg \min_{x} L(x,\beta^{k}) \quad（x-最小化）\\
\beta^{k+1} &amp;amp; := \beta^{k} + \alpha^k \nabla g(\beta) = y^k + \alpha^k(A x^{k+1} -b) \quad (对偶变量更新，\alpha^k为步长)
\end{align*} \qquad(1.5)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;p&gt;Dual Ascent法要求目标函数\(f(x)\)为&lt;strong&gt;强凸函数&lt;/strong&gt;（一般的目标函数难以满足）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;强凸函数&lt;/p&gt;
&lt;p&gt;函数\(f: I \rightarrow R\) 成为强凸的，若\(\exists \alpha &amp;gt; 0\)，使\(\forall (x,y) \in I \times I, \forall t \in [0,1]\)，恒有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span&gt;$f[t x + (1-t)y] \le tf(x) + (1-t) f(y) - t(1-t)\alpha(x-y)^2$&lt;/span&gt;&lt;!-- Has MathJax --&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;1-2-Dual-Decomposition&quot;&gt;&lt;a href=&quot;#1-2-Dual-Decomposition&quot; class=&quot;headerlink&quot; title=&quot;1.2. Dual Decomposition&quot;&gt;&lt;/a&gt;1.2. Dual Decomposition&lt;/h4&gt;&lt;p&gt;Dual Ascent的缺陷就是它对目标函数的限制过于严格。但是它有一个非常好的性质：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当目标函数\(f\)可分（separable）时，整个问题可以拆解成多个子问题，分块优化后得到局部参数，然后汇集起来整体更新全局参数。非常有利于并行化处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;形式化表示：&lt;/p&gt;
&lt;span&gt;$$\begin{align*}
&amp;amp; \min_{x} \quad f(x) = \sum_{i=1}^{m} f_i(x_i) \\
&amp;amp; s.t. \; Ax=\sum_{i=1}^{m} A_ix_i = b
\end{align*}        \qquad(1.6)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;p&gt;拉格朗日函数：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\mathcal{L}(x,\beta) = \sum_{i=1}^{m} \mathcal{L}_i(x&lt;em&gt;i, \beta) = \sum&lt;/em&gt;{i=1}^{m} \left(f_i(x_i) + \beta^T A_i x_i - \frac{1}{N} \beta^T b \right) \qquad(1.7)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;对应的迭代公式：&lt;/p&gt;
&lt;span&gt;$$\begin{align*}
x_{i}^{k+1} &amp;amp; := \arg \min_{x} L_i(x_i,\beta^{k}) \quad（多个x_i并行最小化步）\quad(1)\\
\beta^{k+1} &amp;amp; := \beta^{k} + \alpha^k \nabla g(\beta) = y^k + \alpha^k(A x^{k+1} -b) \quad (汇集整体的x,对偶变量更新) \quad(2)
\end{align*} \qquad\qquad(1.8)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;h4 id=&quot;1-3-扩展拉格朗日乘子法&quot;&gt;&lt;a href=&quot;#1-3-扩展拉格朗日乘子法&quot; class=&quot;headerlink&quot; title=&quot;1.3. 扩展拉格朗日乘子法&quot;&gt;&lt;/a&gt;1.3. 扩展拉格朗日乘子法&lt;/h4&gt;&lt;p&gt;dual ascent方法对于目标函数要求比较苛刻，为了放松假设条件，同时比较好优化，于是就有了Augmented Lagrangians方法，目的就是放松对于\(f(x)\)严格凸的假设和其他一些条件，同时还能使得算法更加稳健。&lt;/p&gt;
&lt;p&gt;具体做法：原有的拉格朗日公式添加惩罚函数项：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\mathcal{L}_{\rho}(x,\beta) = f(x) + \beta^T (Ax-b) + \frac{\rho}{2} {\Vert Ax-b \Vert}_2^2 \qquad(1.9)&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;公式解读：&lt;/p&gt;
&lt;p&gt;&amp;gt;&lt;br&gt;&lt;span&gt;$\mathcal{L}_{\rho}(x,\beta) = f(x) + \overbrace{ \underbrace{\beta^T (Ax-b)}_{拉格朗日乘子法} + \underbrace{ \frac{\rho}{2} {\Vert Ax-b \Vert}_2^2}_{函数惩罚法} }^{增强拉格朗日乘子法} \qquad(n.1.1)$&lt;/span&gt;&lt;!-- Has MathJax --&gt; &lt;/p&gt;
&lt;p&gt;参数迭代公式&lt;/p&gt;
&lt;span&gt;$$\begin{align*}
x^{k+1} &amp;amp; := \arg \min_{x} L(x,\beta^{k}) \quad（x-最小化）\\
\beta^{k+1} &amp;amp; := \beta^{k} + \alpha^k \nabla g(\beta) = y^k + \rho(A x^{k+1} -b) \quad (对偶变量更新，\alpha^k为步长)
\end{align*} \qquad(1.10)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;p&gt;虽然Augmented Lagrangians方法有优势，但也破坏了dual ascent方法的利用分解参数来并行的优势。当\(f\)是separable时，对于Augmented Lagrangians却是not separable的（因为平方项写成矩阵形式无法用之前那种分块形式）&lt;/p&gt;
&lt;h3 id=&quot;2-Alternating-Direction-Method-of-Multipliers-ADMM&quot;&gt;&lt;a href=&quot;#2-Alternating-Direction-Method-of-Multipliers-ADMM&quot; class=&quot;headerlink&quot; title=&quot;2. Alternating Direction Method of Multipliers (ADMM)&quot;&gt;&lt;/a&gt;2. Alternating Direction Method of Multipliers (ADMM)&lt;/h3&gt;&lt;h4 id=&quot;2-1-ADMM概述&quot;&gt;&lt;a href=&quot;#2-1-ADMM概述&quot; class=&quot;headerlink&quot; title=&quot;2.1. ADMM概述&quot;&gt;&lt;/a&gt;2.1. ADMM概述&lt;/h4&gt;&lt;p&gt;为了整合dual ascent可分解性与method multiplers优秀的收敛性质，人们就又提出了改进形式的优化ADMM。目的就是想能分解原函数和扩增函数，以便于在对\(f(x)\)更一般的假设条件下并行优化。&lt;/p&gt;
&lt;p&gt;ADMM从名字可以看到是在原来Method of Multipliers加了个Alternating Direction，可以大概猜想到应该是又想引入新变量，然后交叉换方向来交替优化。形式如下：&lt;/p&gt;
&lt;span&gt;$$\begin{align*}
&amp;amp; min \quad f(x) + g(z)  \\
&amp;amp; s.b \quad Ax + B z = C
\end{align*}  \qquad (2.1)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;blockquote&gt;
&lt;p&gt;其中\(x \in R^n, z \in R^m; A \in R^{p \times n}, B \in R^{p \times m}, C \in R^p\)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;增强Lagrange函数&lt;/p&gt;
&lt;span&gt;$\mathcal{L}_{\rho}(x,z,\beta) = f(x) + g(z) + \underline{ \beta^T(Ax+Bz-C) + \frac{\rho}{2} {\Vert Ax+Bz-C \Vert}_2^2 }  \qquad(2.2)$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;p&gt;从上面形式确实可以看出，ADMM的思想就是想把primal变量、目标函数拆分，但是不再像dual ascent方法那样，将拆分开的\(x_i\)都看做是xx的一部分，后面融合的时候还需要融合在一起，而是最先开始就将拆开的变量分别看做是不同的变量xx和zz，同时约束条件也如此处理，这样的好处就是后面不需要一起融合xx和zz，保证了前面优化过程的可分解性。于是ADMM的优化就变成了如下序贯型迭代（这正是被称作alternating direction的缘故）：&lt;/p&gt;
&lt;h4 id=&quot;2-2-参数迭代公式（缩放形式）&quot;&gt;&lt;a href=&quot;#2-2-参数迭代公式（缩放形式）&quot; class=&quot;headerlink&quot; title=&quot;2.2. 参数迭代公式（缩放形式）&quot;&gt;&lt;/a&gt;2.2. 参数迭代公式（缩放形式）&lt;/h4&gt;&lt;p&gt;定义残差：\(\underline{r = Ax+Bz-C}\)，令 \(\underline{\mu = \frac{1}{\rho}\beta} \in R^p\)（对偶变量归一化）. 增强Lagrange函数等价于：&lt;/p&gt;
&lt;span&gt;$\mathcal{L}_{\rho}(x,z,r,\mu) = f(x) + g(z) + \underline{ \frac{\rho}{2} {\Vert r + \mu \Vert}_2^2 - \frac{\rho}{2} {\Vert \mu \Vert}_2^2 }  \qquad(2.3)$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;blockquote&gt;
&lt;p&gt;推导如下：&lt;/p&gt;
&lt;span&gt;$$\begin{align*}
\beta^T(Ax+Bz-C) + \frac{\rho}{2} {\Vert Ax+Bz-C \Vert}_2^2 &amp;amp; = \beta^T \cdot r + \frac{\rho}{2} {\Vert r \Vert}_2^2 \\
&amp;amp; = \frac{\rho}{2} {\left \Vert  r + \frac{1}{\rho} \beta \right \Vert}_2^2 - \frac{1}{2\rho} {\Vert \beta \Vert}_2^2 \\
&amp;amp; = \frac{\rho}{2} {\Vert r + \mu \Vert}_2^2 - \frac{\rho}{2} {\Vert \mu \Vert}_2^2
\end{align*}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt; 
&lt;/blockquote&gt;
&lt;p&gt;ADMM迭代公式转化为：&lt;/p&gt;
&lt;span&gt;$$\begin{cases}
    x^{k+1} = \arg \min_{x} \left( f(x) + \frac{\rho}{2} {\Vert Ax^k + Bz^k - C + \mu^k \Vert}_2^2 \right) \qquad (1) \\
    z^{k+1} = \arg \min_{z} \left( g(z) + \frac{\rho}{2} {\Vert Ax^{k+1} + Bz^k - C + \mu^k \Vert}_2^2 \right) \qquad(2)\\
    \mu^{k+1} = \mu^k + Ax^{k+1} + Bz^{k+1} - C \qquad\qquad\qquad(3)
    \end{cases} \qquad(2.4)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;公式(2.4)的理解&lt;/p&gt;
&lt;p&gt;  典型的利用ADMM分布式求解的问题中，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公式（1）用于各部分数据的&lt;strong&gt;局部参数更新&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;公式（2）用于将个部分得到的局部优化参数综合成&lt;strong&gt;全局的参数&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;公式（3）用于&lt;strong&gt;对偶变量的更新&lt;/strong&gt;，是使得整个迭代过程稳定和高效率的关键。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-3-参数迭代公式推导&quot;&gt;&lt;a href=&quot;#2-3-参数迭代公式推导&quot; class=&quot;headerlink&quot; title=&quot;2.3. 参数迭代公式推导&quot;&gt;&lt;/a&gt;2.3. 参数迭代公式推导&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;\(f(x)\)为二次函数式时&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如：\(f(x) = \frac{1}{2} x^T P x + q^T x + r\)。损失函数为平方损失时，符合这一场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;令\\(\underline{-v = Bz^k - C + \mu^k}\\)，对参数\\(x\\)求偏导：
&lt;/code&gt;&lt;/pre&gt;&lt;span&gt;$$\begin{align*}
\frac{\partial{ \left( f(x) + \frac{\rho}{2} {\Vert Ax - v \Vert}_2^2 \right) }} {\partial{x}} 
&amp;amp; = \frac{\partial{ \left( \frac{1}{2} x^T P x + q^T x + r + \frac{\rho}{2} {\Vert Ax - v \Vert}_2^2 \right) }} {\partial{x}} \\
&amp;amp; = \frac{\partial{(\frac{1}{2} x^T P x)}}{\partial{x}} + \frac{\partial{(q^T x + r)}}{\partial{x}} + \underline{ \frac{\rho}{2} \cdot \frac{(Ax)^T(Ax) - 2(Ax)^Tv + {\Vert v \Vert}_2^2} {\partial{x}} } \\
&amp;amp; = Px + (q^T)^T + \underline { \frac{\rho}{2} \left( 2A^TAx - 2A^Tv\right)} \\
&amp;amp; = Px + q + \underline{ \rho A^TAx - \rho A^T v } \\
&amp;amp; = (P + \rho A^TA)x + (q - \rho A^T v) = 0
\end{align*}  \qquad(2.5)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;pre&gt;&lt;code&gt;偏导数为0，得到参数\\(x\\)的迭代公式：

$$
x = (P + \rho A^TA)^{-1} \cdot (\rho A^T v - q) \quad (v中含有参数z和\mu) \qquad(2.6)
$$

&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;\(f(x)\)为norm 1范数形式时&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如：\(f(x) = \lambda {\Vert x \Vert}_{1} = \lambda (|x_1| + |x_2| + \cdots + |x_n|)\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  对参数\(x\)求偏导：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1). 当\(\frac{\partial {f(x)}} {\partial{x}} = \lambda\)时&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;span&gt;$$\begin{align*}
\frac{\partial{ \left( f(x) + \frac{\rho}{2} {\Vert Ax - v \Vert}_2^2 \right) }} {\partial{x}} 
&amp;amp; = \frac{\partial{\left( \lambda{\Vert x \Vert}_1 + \frac{\rho}{2} {\Vert Ax - v \Vert}_2^2\right)}} {\partial{x}} \\
&amp;amp; = \frac{\partial{(\lambda {\Vert x \Vert}_1)}} {\partial{x}} + \underline{ \frac{\rho}{2} \cdot \frac{(Ax)^T(Ax) - 2(Ax)^Tv + {\Vert v \Vert}_2^2} {\partial{x}} } \\
&amp;amp; = \lambda I + \underline{ \rho A^TAx - \rho A^T v } \\
&amp;amp; = \rho A^TAx + (\lambda I - \rho A^T v) = 0
\end{align*} \qquad(2.7)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;pre&gt;&lt;code&gt;取\\(A=I\\)，则有

$$
x^{*} = I_{n \times p} v - \frac{\lambda}{\rho} I_{n \times 1} &amp;gt; 0  \qquad(2.7-1)
$$

+ (2). 当\\(\frac{\partial {f(x)}} {\partial{x}} = -\lambda\\)时
&lt;/code&gt;&lt;/pre&gt;&lt;span&gt;$$\begin{align*}
\frac{\partial{ \left( f(x) + \frac{\rho}{2} {\Vert Ax - v \Vert}_2^2 \right) }} {\partial{x}} 
&amp;amp; = \frac{\partial{\left( \lambda{\Vert x \Vert}_1 + \frac{\rho}{2} {\Vert Ax - v \Vert}_2^2\right)}} {\partial{x}} \\
&amp;amp; = \frac{\partial{(\lambda {\Vert x \Vert}_1)}} {\partial{x}} + \underline{ \frac{\rho}{2} \cdot \frac{(Ax)^T(Ax) - 2(Ax)^Tv + {\Vert v \Vert}_2^2} {\partial{x}} } \\
&amp;amp; = -\lambda I + \underline{ \rho A^TAx - \rho A^T v } \\
&amp;amp; = \rho A^TAx - (\lambda I + \rho A^T v) = 0
\end{align*} \qquad(2.8)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;pre&gt;&lt;code&gt;取\\(A=I\\)，则有

$$
x^{*} = I_{n \times p} v + \frac{\lambda}{\rho} I_{n \times 1} &amp;lt; 0 \qquad(2.8-1)
$$

+ 软阈值（Soft Thresholding）

    综合(1)和(2)可得，参数\\(x^{*}\\)形式为：
&lt;/code&gt;&lt;/pre&gt;&lt;span&gt;$$x^{*} = S_{\frac{\lambda}{\rho}}(v) \rightarrow S_{a}(v) = (v-a)_{+} - (-v-a)_{+} = 
\begin{cases}
v-a, &amp;amp; \quad if \quad v \ge a \\
\quad 0, &amp;amp;\quad if \quad -a &amp;lt; v &amp;lt; a \\
v+a, &amp;amp; \quad if \quad v \le -a
\end{cases} \qquad(2.9)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; \\(a = \frac{\lambda}{\rho}\\) 是常数
&amp;gt; 
&amp;gt; [软阈值概念与示例](http://blog.csdn.net/abcjennifer/article/details/8572994)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-ADMM-for-Lasso-Model&quot;&gt;&lt;a href=&quot;#3-ADMM-for-Lasso-Model&quot; class=&quot;headerlink&quot; title=&quot;3. ADMM for Lasso Model&quot;&gt;&lt;/a&gt;3. ADMM for Lasso Model&lt;/h3&gt;&lt;h4 id=&quot;3-1-Lasso问题与ADMM&quot;&gt;&lt;a href=&quot;#3-1-Lasso问题与ADMM&quot; class=&quot;headerlink&quot; title=&quot;3.1. Lasso问题与ADMM&quot;&gt;&lt;/a&gt;3.1. Lasso问题与ADMM&lt;/h4&gt;&lt;p&gt;基于\(l1\)正则的线性回归（即Lasso模型）的目标函数，形式化表示：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\min_{w} \; \frac{1}{2} {\Vert Xw - Y\Vert}_2^2 + \lambda {\Vert w \Vert}_1 \qquad(3.1)&lt;br&gt;    $$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;符号解释：&lt;br&gt;&lt;br&gt;\(w \in R^n\)：参数向量，n为向量元素个数，即特征数；&lt;br&gt;&lt;br&gt;\(X \in R^{m \times n}\)：表示训练数据特征矩阵,m为训练集个数；&lt;br&gt;&lt;br&gt;\(Y \in R^m\)：样本label组成的m维向量；&lt;br&gt;&lt;br&gt;\(\lambda\)：正则化因子（初始值可通过交叉验证获得）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Lasso目标函数格式：”loss + regularization”&lt;/p&gt;
&lt;p&gt;  目标函数适用ADMM框架求解形式，改写为&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;span&gt;$$\begin{align*}
&amp;amp; \min \quad \overbrace{\frac{1}{2} {\Vert Xw - Y\Vert}_2^2}^{f(w)} + \overbrace{ \lambda {\Vert \theta \Vert}_1}^{g(\theta)} \\
&amp;amp; s.b \qquad w - \theta = 0
\end{align*} \qquad(3.2)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;目标函数可分（separable）&lt;/p&gt;
&lt;p&gt;  训练数据集切分为\(L\)个部分，分布式训练：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;span&gt;$$\begin{align*}
\frac{1}{2} \sum_{l=1}^{L} {\Vert X_{l} w_l - Y_l\Vert}^2 + \frac{\lambda}{L} \sum_{l=1}^{L} {\Vert w \Vert}_1 = \sum_{l=1}^{L} \left( \underline{ \frac{1}{2} {\Vert X_{l} w_l - Y_l\Vert}^2 + \frac{\lambda}{L} {\Vert w \Vert}_1} \right)
\end{align*} \quad(3.3)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;p&gt;这里，\(l=1,2,\cdots,L\)表示数据集划分为\(L\)个子集，\(w_l\)对应于第\(l\)部分数据上得到的参数。&lt;/p&gt;
&lt;p&gt;将其改写成分布式ADMM框架可求解的形式。令\(f_l(w&lt;em&gt;l) = \frac{1}{2} {\Vert X&lt;/em&gt;{l} w_l - Y_l\Vert}^2, g_l(w) = \frac{\lambda}{L} {\Vert w \Vert}_1 \)&lt;/p&gt;
&lt;p&gt;&amp;gt;&lt;br&gt;&lt;span&gt;$$\begin{align*}
&amp;amp; \min \quad f_l(w_l) + g_l(\theta) \\
&amp;amp; s.b \qquad w_l - \theta = 0
\end{align*} \quad l=1,2,\cdots,L   \qquad(n.3.2)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;&lt;/p&gt;
&lt;p&gt;每部分数据，对应的增强Lagrange函数为：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\mathcal{L}_{\rho}(w_l, \theta, \beta_l) = \frac{1}{2} {\Vert X_l w_l - Y_l\Vert}_2^2 + \frac{\lambda}{L} {\Vert \theta \Vert}_1 + \beta_l^T (w_l-\theta) + \frac{\rho}{2} {\Vert w_l - \theta \Vert}_2^2  \qquad(3.4)&lt;br&gt;    $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参数\(w\)的迭代公式&lt;/p&gt;
&lt;p&gt;  由于\(f(w)\)为二次函数式，即:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  $$&lt;br&gt;  f(w) = \frac{1}{2} {\Vert Xw - Y\Vert}_2^2 = \frac{1}{2} w^T X^T X w - Y^T Xw + \frac{1}{2} {\Vert Y \Vert}_2^2&lt;br&gt;  $$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  相应参数&lt;/p&gt;
&lt;p&gt;  \(P=X^T X, q=-X^T Y, A=I&lt;em&gt;{n \times n}, B=-I&lt;/em&gt;{n \times n}, v=\theta^t - \frac{1}{\rho} \beta^t \)。对参数\(w\)求偏导，得到参数\(w\)的迭代公式：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;span&gt;$$\begin{align*}
w^{k+1} &amp;amp; = (P + \rho A^TA)^{-1} \cdot (\rho A^T v - q) \\
&amp;amp; = (X^T X + \rho I)^{-1} \cdot (\rho v + X^T Y) \\
&amp;amp; = (X^T X + \rho I)^{-1} \cdot \left(X^T Y + \rho(\theta^k - \frac{1}{\rho} \beta^k) \right) \\
&amp;amp; = (X^T X + \rho I)^{-1} \cdot (X^T Y + \rho \theta^k - \beta^k)
\end{align*}  \qquad(3.5)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参数\(\theta\)的迭代公式&lt;/p&gt;
&lt;p&gt;  由于\(g(\theta)\)是\(l1\)范数形式，即：&lt;/p&gt;
&lt;p&gt;  &amp;gt;&lt;br&gt;  $$&lt;br&gt;  g(\theta) = \lambda {\Vert \theta \Vert}_1 = \lambda (|\theta_1| + |\theta_2| + \cdots + |\theta_n|)&lt;br&gt;  $$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;span&gt;$$\theta^{k+1} = S_{\frac{\lambda}{\rho}}(w^{k+1}+\frac{1}{\rho}\beta^k) = 
\begin{cases}
    v-a, &amp;amp; \quad if \quad v \ge a \\
    \quad 0, &amp;amp;\quad if \quad -a &amp;lt; v &amp;lt; a \\
    v+a, &amp;amp; \quad if \quad v \le -a
    \end{cases} \qquad(3.6)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参数\(\beta\)的迭代公式&lt;/p&gt;
&lt;p&gt;  $$&lt;br&gt;  \beta^{k+1} = \beta^{k} + \rho(w^{k+1} - \theta^{k+1})  \qquad(3.7)&lt;br&gt;  $$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;3-2-ADMM分布式更新参数过程&quot;&gt;&lt;a href=&quot;#3-2-ADMM分布式更新参数过程&quot; class=&quot;headerlink&quot; title=&quot;3.2. ADMM分布式更新参数过程&quot;&gt;&lt;/a&gt;3.2. ADMM分布式更新参数过程&lt;/h4&gt;&lt;p&gt;这里给出参数迭代公式：&lt;/p&gt;
&lt;span&gt;$$\begin{align*}
w_l^{k+1} &amp;amp;= \arg \min_{w} \left( f_l(w) + \frac{\rho}{2} {\Vert w + \theta^k + \mu_l^k \Vert}_2^2 \right) \qquad (1) \\
z^{k+1} &amp;amp;= \arg \min_{\theta} \left( g_l(\theta) + \frac{\rho}{2} {\Vert \theta - \overline{w^{k+1}} - \overline{\mu^k} \Vert}_2^2 \right) \quad(2)\\
\mu_l^{k+1} &amp;amp;= \mu_l^k + w_l^{k+1} - \theta^{k+1} \qquad\quad\qquad\qquad\qquad(3)
\end{align*} \qquad(3.8)$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
&lt;p&gt;分布式环境下执行过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，再每个数据分块上，分别执行(1)中对应的更新，得到该数据块上更新后的参数（迭代过程）。这一步是分布式进行的，而且各个数据块之间不需要通信；&lt;/li&gt;
&lt;li&gt;然后，根据各部分更新得到的局部参数，执行公式（2）得到综合以后的整体参数\(\theta\)；&lt;/li&gt;
&lt;li&gt;最后，根据公式(3)更新对偶变量\(\mu\)（\(\beta的归一化\)），并将更新后的整体参数\(\theta\)和\(\mu\)分发至各个数据块的处理单元。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;3-3-分布式解决方案&quot;&gt;&lt;a href=&quot;#3-3-分布式解决方案&quot; class=&quot;headerlink&quot; title=&quot;3.3. 分布式解决方案&quot;&gt;&lt;/a&gt;3.3. 分布式解决方案&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;MapReduce&lt;ul&gt;
&lt;li&gt;Mapper：（1） &lt;/li&gt;
&lt;li&gt;Reducer：（2），（3）&lt;/li&gt;
&lt;li&gt;代码示例：&lt;a href=&quot;https://github.com/intentmedia/admm.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;admm for hadoop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MPI： 提供Allreduce和Broadcast操作，用于机器之间的通信&lt;ul&gt;
&lt;li&gt;计算单元：（1） &lt;/li&gt;
&lt;li&gt;Allreduce：(2)&lt;/li&gt;
&lt;li&gt;Broadcast: (3)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rabit：&lt;ul&gt;
&lt;li&gt;仅包含MPI的一个Allreduce子集，提供容错；&lt;/li&gt;
&lt;li&gt;运行在Yarn上，避免MPI和Hadoop之间的数据传输；&lt;/li&gt;
&lt;li&gt;计算过程同MPI；&lt;/li&gt;
&lt;li&gt;与DMLC强耦合&lt;/li&gt;
&lt;li&gt;示例：&lt;a href=&quot;http://10.210.228.76/opticlick/admm/tree/master&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;opticlick-admm@baigang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spark&lt;ul&gt;
&lt;li&gt;单结点：(1)&lt;/li&gt;
&lt;li&gt;treeAggregate: (2), 相当于Allreduce&lt;/li&gt;
&lt;li&gt;（全局）广播变量 &lt;/li&gt;
&lt;li&gt;代码示例：&lt;a href=&quot;https://github.com/dieterichlawson/admm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;admm for spark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;3-4-ADMM适用范围&quot;&gt;&lt;a href=&quot;#3-4-ADMM适用范围&quot; class=&quot;headerlink&quot; title=&quot;3.4. ADMM适用范围&quot;&gt;&lt;/a&gt;3.4. ADMM适用范围&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;目标函数结构为”loss + regularation”&lt;/li&gt;
&lt;li&gt;目标函数可分：分布式求解&lt;/li&gt;
&lt;li&gt;在ML中以loss function是平方损失的模型，都可以用ADMM求解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;3-5-相关资料&quot;&gt;&lt;a href=&quot;#3-5-相关资料&quot; class=&quot;headerlink&quot; title=&quot;3.5. 相关资料&quot;&gt;&lt;/a&gt;3.5. 相关资料&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;Next…&quot;&gt;&lt;a href=&quot;#Next…&quot; class=&quot;headerlink&quot; title=&quot;Next…&quot;&gt;&lt;/a&gt;Next…&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;跑通流程&lt;/strong&gt;：熟悉&lt;a href=&quot;http://10.210.228.76/opticlick/admm/tree/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;opticlick-admm@baigang&lt;/a&gt;运行环境和代码，使用样例数据跑通流程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CTR－特征工程&lt;/strong&gt;：熟悉数据接口和CTR预估特征工程代码（脚本配置化得到组合特征等）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;推荐－特征工程&lt;/strong&gt;：根据现有数据，特征工程设计＋开发；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于Rabit和DMLC的模型和pipeline开发&lt;/strong&gt;：熟悉rabit和dmlc-core框架、代码和接口，为后续必要的离线模型pipeline开发作准备；&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-约束优化问题一般解决方案&quot;&gt;&lt;a href=&quot;#1-约束优化问题一般解决方案&quot; class=&quot;headerlink&quot; title=&quot;1. 约束优化问题一般解决方案&quot;&gt;&lt;/a&gt;1. 约束优化问题一般解决方案&lt;/h3&gt;&lt;h4 id=&quot;1-1-Dual-Ascent
    
    </summary>
    
      <category term="other" scheme="http://sinaad.github.io/xfe/categories/other/"/>
    
    
      <category term="algo" scheme="http://sinaad.github.io/xfe/tags/algo/"/>
    
      <category term="hexo-math" scheme="http://sinaad.github.io/xfe/tags/hexo-math/"/>
    
      <category term="latex" scheme="http://sinaad.github.io/xfe/tags/latex/"/>
    
      <category term="mathjax" scheme="http://sinaad.github.io/xfe/tags/mathjax/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo和github创建团队博客</title>
    <link href="http://sinaad.github.io/xfe/2016/02/18/create-team-blog-with-hexo-and-github/"/>
    <id>http://sinaad.github.io/xfe/2016/02/18/create-team-blog-with-hexo-and-github/</id>
    <published>2016-02-18T14:07:44.000Z</published>
    <updated>2016-02-19T07:26:21.000Z</updated>
    
    <content type="html">&lt;p&gt;为了沉淀团队技术分享，所以最近需要创建一个前端团队博客，确定了下面几个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费自由的空间，同时正好利用之前创建sinaad这个github组织，所以选用&lt;code&gt;github&lt;/code&gt;作为承载空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;markdown&lt;/code&gt;是一种对码农来说比较自然的写博文的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;找了一圈后，确定jeklly或者hexo，jeklly通过gem安装，hexo使用nodejs安装，基于前端对nodejs的熟悉，最后选用了hexo。&lt;/p&gt;
&lt;h2 id=&quot;hexo&quot;&gt;&lt;a href=&quot;#hexo&quot; class=&quot;headerlink&quot; title=&quot;hexo&quot;&gt;&lt;/a&gt;hexo&lt;/h2&gt;&lt;p&gt;了解hexo，请戳：&lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hexo.io&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;你需要先安装一个node， 请戳：&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完成后在命令行中输入&lt;code&gt;node -v&lt;/code&gt;， 出现如下类似版本号说明安装成功，新版本的node都自带npm（node package manager node的包管理工具，后续的hexo通过npm安装）&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;node -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v5.&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;hexo安装和使用&quot;&gt;&lt;a href=&quot;#hexo安装和使用&quot; class=&quot;headerlink&quot; title=&quot;hexo安装和使用&quot;&gt;&lt;/a&gt;hexo安装和使用&lt;/h2&gt;&lt;h3 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等待安装完成&lt;/p&gt;
&lt;h3 id=&quot;初始化hexo项目&quot;&gt;&lt;a href=&quot;#初始化hexo项目&quot; class=&quot;headerlink&quot; title=&quot;初始化hexo项目&quot;&gt;&lt;/a&gt;初始化hexo项目&lt;/h3&gt;&lt;p&gt;进入你将要存放本地blog repo的目录，创建一个hexo初始项目，如xfe到当前目录&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; some-dir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init xfe&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;等待初始化结束&lt;/p&gt;
&lt;h3 id=&quot;创建一篇文章&quot;&gt;&lt;a href=&quot;#创建一篇文章&quot; class=&quot;headerlink&quot; title=&quot;创建一篇文章&quot;&gt;&lt;/a&gt;创建一篇文章&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; xfe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new post-file-name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#hexo n&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;成功后会在xfe目录的source/_posts下自动创建一个post-file-name.md文件&lt;/p&gt;
&lt;p&gt;接下来用markdown编辑这个文档，用心写好你的文章，保存&lt;/p&gt;
&lt;h3 id=&quot;编译文章&quot;&gt;&lt;a href=&quot;#编译文章&quot; class=&quot;headerlink&quot; title=&quot;编译文章&quot;&gt;&lt;/a&gt;编译文章&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#hexo g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;本地查看文章效果&quot;&gt;&lt;a href=&quot;#本地查看文章效果&quot; class=&quot;headerlink&quot; title=&quot;本地查看文章效果&quot;&gt;&lt;/a&gt;本地查看文章效果&lt;/h3&gt;&lt;p&gt;hexo提供了一个本地server能够在本地启动一个静态服务器查看文章效果&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#或者使用hexo s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认在4000端口启动，当然你也可以通过xfe根目录下的_config.yml文件进行配置（_config.yml有很多高级配置，可以自行查看hexo的文档了解～）&lt;/p&gt;
&lt;p&gt;启动后在浏览器上通过&lt;a href=&quot;http://localhost:4000即可访问&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000即可访问&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;发布到github&quot;&gt;&lt;a href=&quot;#发布到github&quot; class=&quot;headerlink&quot; title=&quot;发布到github&quot;&gt;&lt;/a&gt;发布到github&lt;/h2&gt;&lt;p&gt;在发布到github前你需要先了解下github的gh-pages相关分支，这里我就不赘述了，搜索一下就清楚了&lt;br&gt;大致是你在github上申请的一个repo，经过简单的设置，gh-pages分支可以被自动发布成静态站点，之后可以通过reponame.github.io访问这个站点，当然你也可以自己申请一个域名，cname到这个上面来&lt;/p&gt;
&lt;p&gt;好了，假装我已经自动配置完成了一个gh-pages，他的repo地址为&lt;a href=&quot;https://github.com/sinaad/xfe.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/sinaad/xfe.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从前面的步骤，我得到了一个hexo初始化好的xfe目录，接下来，需要把它变成一个git repo，通过下面的命令&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; xfe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后添加远程push跟pull的地址， 把这个本地仓库跟远程github上的repo关联&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin https://github.com/sinaad/xfe.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，你需要吧xfe文件夹的内容推送到remote的gh-pages分支上去， 这里需要用到强制推送，否则你就先pull一下在push&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 提交&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git ci -m &lt;span class=&quot;string&quot;&gt;&quot;first commit&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建并切换到本地gh-pages分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git co -b gh-pages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 强制提交gh-pages分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push &lt;span class=&quot;operator&quot;&gt;-f&lt;/span&gt; origin gh-pages&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果提交成功了，就可以通过&lt;a href=&quot;http://sinaad.github.io/xfe进行访问了，&quot;&gt;http://sinaad.github.io/xfe进行访问了，&lt;/a&gt; 打工告成！！！&lt;/p&gt;
&lt;h3 id=&quot;其他方法&quot;&gt;&lt;a href=&quot;#其他方法&quot; class=&quot;headerlink&quot; title=&quot;其他方法&quot;&gt;&lt;/a&gt;其他方法&lt;/h3&gt;&lt;p&gt;上面描述了一种先通过hexo初始化项目，后关联github的方式来创建，当然你也可以先申请repo，然后通过&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/sinaad/xfe.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;来创建这个xfe目录，并拉取gh-pages分支&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git co -b gh-pages&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull origin gh-pages&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在进入xfe目录，使用hexo init/new来初始化并创建文章，最后在push到gh-pages中的步骤来完成&lt;/p&gt;
&lt;h2 id=&quot;真相&quot;&gt;&lt;a href=&quot;#真相&quot; class=&quot;headerlink&quot; title=&quot;真相&quot;&gt;&lt;/a&gt;真相&lt;/h2&gt;&lt;p&gt;其实，上面所说的关联github的方法主要是我想让你熟悉下git的一些操作，hexo已经贴心的提供了一个很简单的工具进行关联repo（hexo deploy命令）&lt;/p&gt;
&lt;p&gt;你只要通过下面几步：&lt;/p&gt;
&lt;p&gt;1.安装hexo-deployer-git插件&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-deployer-git --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.配置远程git repo地址和deploy的方式&lt;/p&gt;
&lt;p&gt;找到根目录下的_config.yml文件，找到并配置下面的内容&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Deployment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## Docs: https://hexo.io/docs/deployment.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repository: https://github.com/sinaad/xfe.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: gh-pages&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3、编译并使用&lt;code&gt;hexo deploy&lt;/code&gt;命令进行发布&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#hexo g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#hexo d&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大功告成，请不要打脸..&lt;/p&gt;
&lt;h2 id=&quot;如何贡献文章&quot;&gt;&lt;a href=&quot;#如何贡献文章&quot; class=&quot;headerlink&quot; title=&quot;如何贡献文章　&quot;&gt;&lt;/a&gt;如何贡献文章　&lt;/h2&gt;&lt;p&gt;如果已经有了初始化好的hexo的git repo，你要贡献文章，那么你只需要按照下面的步骤来做：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据第一部分的要求安装好node和hexo&lt;/li&gt;
&lt;li&gt;检出&lt;a href=&quot;https://github.com/sinaad/xfe.git的gh-pages分支&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/sinaad/xfe.git的gh-pages分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;为了更好的审核文章质量，请在检出的gh-pages分支上创建一个你自己的名字命名的分支&lt;/li&gt;
&lt;li&gt;通过hexo new的步骤创建文章并完成文章的编写，并提交到自己的分支&lt;/li&gt;
&lt;li&gt;通知相关技术组成员进行文章审核&lt;/li&gt;
&lt;li&gt;审核通过后由相关负责人进行合并到gh-pages&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;感谢对知识的无私贡献&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;其实没什么好总结的，&lt;a href=&quot;http://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hexo.io&lt;/a&gt; 上都写的很清楚，hexo还提供了各种丰富的风格包可以简单安装，你还可以自己看看然后个性化你的blog&lt;/p&gt;
&lt;p&gt;最后，欢迎关注 &lt;a href=&quot;https://sinaad.github.io/xfe&quot;&gt;https://sinaad.github.io/xfe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;h3 id=&quot;配置多说评论框&quot;&gt;&lt;a href=&quot;#配置多说评论框&quot; class=&quot;headerlink&quot; title=&quot;配置多说评论框&quot;&gt;&lt;/a&gt;配置多说评论框&lt;/h3&gt;&lt;p&gt;国内，多说算是比较好的一个评论管理平台，hexo也能很简单的集成多说&lt;br&gt;1、访问 &lt;a href=&quot;http://duoshuo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://duoshuo.com/&lt;/a&gt; ，点我要安装，按步骤填写&lt;br&gt;2、找到多说域名前面你填入的那个子域名，比如sinaad-xfe&lt;br&gt;3、配置_config.yml文件&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Duoshuo ShortName&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;duoshuo_shortname: sinaad-xfe&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置tags&quot;&gt;&lt;a href=&quot;#配置tags&quot; class=&quot;headerlink&quot; title=&quot;配置tags&quot;&gt;&lt;/a&gt;配置tags&lt;/h3&gt;&lt;p&gt;根据上面的步骤完成后，点击tags是404的页面，需要通过下面的步骤来配置&lt;/p&gt;
&lt;p&gt;1、通过命令生成tags页面&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo new page &lt;span class=&quot;string&quot;&gt;&quot;tags&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2、编辑生成的tags页面source/tags/index.md&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: Tagcloud&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;02&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;: tags&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;comments: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、在新建的文章开头添加tags: [tag1,tag2,tag3], 类似格式即可&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: 当前端也拥有 Server 的能力&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;02&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: [js,server,ServiceWorker]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4、如果tags为中文，为了避免路径中出现中文，可以在_config.yml中配置tags的map&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Category &amp;amp; Tag&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    服务端: server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    前端: fe&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;配置categories&quot;&gt;&lt;a href=&quot;#配置categories&quot; class=&quot;headerlink&quot; title=&quot;配置categories&quot;&gt;&lt;/a&gt;配置categories&lt;/h3&gt;&lt;p&gt;同tags, 把tags改成categories即可&lt;/p&gt;
&lt;h3 id=&quot;部署的不是xxx-github-com-目录而是某个子目录xxx-github-com-xfe的情况&quot;&gt;&lt;a href=&quot;#部署的不是xxx-github-com-目录而是某个子目录xxx-github-com-xfe的情况&quot; class=&quot;headerlink&quot; title=&quot;部署的不是xxx.github.com/目录而是某个子目录xxx.github.com/xfe的情况&quot;&gt;&lt;/a&gt;部署的不是xxx.github.com/目录而是某个子目录xxx.github.com/xfe的情况&lt;/h3&gt;&lt;p&gt;修改_config.yml中的配置&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# URL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url: http://sinaad.github.io/xfe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root: /xfe/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink: :year/:month/:day/:title/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink_defaults:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;增加rss功能&quot;&gt;&lt;a href=&quot;#增加rss功能&quot; class=&quot;headerlink&quot; title=&quot;增加rss功能&quot;&gt;&lt;/a&gt;增加rss功能&lt;/h3&gt;&lt;p&gt;1、安装对应的feed插件&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2、配置_config.yml，按如下配置：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Set rss to false to disable feed link.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Leave rss as empty to use site&#39;s feed link.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Set rss to specific value if you have burned your feed already.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rss: atom.xml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3、从新部署文件&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#这里不是故意写两遍，当你遇到首页只有一篇文章摘要的时候，执行两边能解决问题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;欢迎评论补充你遇到的问题～&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;为了沉淀团队技术分享，所以最近需要创建一个前端团队博客，确定了下面几个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;免费自由的空间，同时正好利用之前创建sinaad这个github组织，所以选用&lt;code&gt;github&lt;/code&gt;作为承载空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;markd
    
    </summary>
    
      <category term="other" scheme="http://sinaad.github.io/xfe/categories/other/"/>
    
    
      <category term="blog" scheme="http://sinaad.github.io/xfe/tags/blog/"/>
    
      <category term="github" scheme="http://sinaad.github.io/xfe/tags/github/"/>
    
      <category term="hexo" scheme="http://sinaad.github.io/xfe/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>当前端也拥有 Server 的能力</title>
    <link href="http://sinaad.github.io/xfe/2016/02/18/when-fe-has-the-power-of-server/"/>
    <id>http://sinaad.github.io/xfe/2016/02/18/when-fe-has-the-power-of-server/</id>
    <published>2016-02-18T08:29:25.000Z</published>
    <updated>2016-02-19T03:46:56.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.barretlee.com/blog/2016/02/16/when-fe-has-the-power-of-server/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.barretlee.com/blog/2016/02/16/when-fe-has-the-power-of-server/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天看了不少文章，比较感兴趣的是 Cache API。它是浏览器 Request/Response 的缓存管理工具，其使用风格和运用场景让我瞬间联想到了 ServiceWorker 和 Fetch API，相信很多同学也多次看到过这两个东西，本文会对它们做一个简洁的介绍，并谈一谈我对这些新玩具的看法。&lt;/p&gt;
&lt;h3 id=&quot;Fetch-API&quot;&gt;&lt;a href=&quot;#Fetch-API&quot; class=&quot;headerlink&quot; title=&quot;Fetch API&quot;&gt;&lt;/a&gt;Fetch API&lt;/h3&gt;&lt;p&gt;传统的 XMLHttpRequest，出了两个版本，在 XHR2.0 中引入了跨源请求、上传进度事件和对二进制数据的支持等，这些 API 的增强让 AJAX 可以很方便地与 HTML5 API 相结合，例如 File System API、Web Audio API、WebGL 等，让前端对音视频的处理和富客户端元素的处理更加有亲和力。&lt;br&gt;作为一个与后端交互的通道，XHR2.0 的接口封装依然过于底层。看看 jQuery 对 AJAX 的封装，再回头看看我们今天要介绍的 Fetch API，不得不惊叹，浏览器已经在应用层面思考着功能的拓展，依托着 Promise 产出了十分友好的新一套接口。&lt;br&gt;以前我们使用 XHR 去请求一个资源，会这么做：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Just getting XHR is a mess!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.XMLHttpRequest) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XMLHttpRequest();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.ActiveXObject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ActiveXObject(&lt;span class=&quot;string&quot;&gt;&#39;Msxml2.XMLHTTP&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      request = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ActiveXObject(&lt;span class=&quot;string&quot;&gt;&#39;Microsoft.XMLHTTP&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.onreadstatechange = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// handle data;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.open(&lt;span class=&quot;string&quot;&gt;&#39;GET&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;http://barretlee.com/test.json&#39;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request.send(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而使用 Fetch API，我们只需要：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;http://barretlee.com/test.json&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Convert to JSON&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.json();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(val); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于 Text/HTML 和 Blob 等格式的请求和转化也是异常方便：我要说话&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Text/HTML 请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;/next/page&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.text();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;text&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(text); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Blob 流&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;flowers.jpg&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.blob();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;blob&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.querySelector(&lt;span class=&quot;string&quot;&gt;&#39;img&#39;&lt;/span&gt;).src = URL.createObjectURL(blob);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Fetch API 让我们更加关注请求和响应之间的交互，而不是聚焦在如何请求和如何处理响应两个问题上。&lt;/p&gt;
&lt;p&gt;当然，它也存在几个相比 XHR 不足的地方，首先它不能 abort 请求，同时也不能获取请求过程中的 progress 状态，当然也没有 timeout 超时处理。Fetch API 是基于 Promise 的，而 Promise 的状态只有 pending、resolve、reject，不会出现诸如 pending(80%) 的状态提示；我们也无法对一个 Promise chains 做 abort 处理，这些都是能够理解并且接受的。&lt;/p&gt;
&lt;p&gt;我也相信，Fetch API 有能力提供这些状态信息和附加的 API，只是在这个不成熟的环境下，它目前不需要迈这么大的步子。&lt;/p&gt;
&lt;h3 id=&quot;ServiceWorker&quot;&gt;&lt;a href=&quot;#ServiceWorker&quot; class=&quot;headerlink&quot; title=&quot;ServiceWorker&quot;&gt;&lt;/a&gt;ServiceWorker&lt;/h3&gt;&lt;p&gt;ServiceWorker，简单而言就是一个放在前端的 HTTP 拦截器，比如我们要请求一个不存在的 URI 如：/test/a.html，直接请求就会响应 404，而如果我们预先在 ServiceWorker 中注册了这个地址，并且指定响应内容，当再次请求时，你会看到结果是存在的，举个例子：我要说话&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;!—demo.html—&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;navigator.serviceWorker.register(&quot;worker.js&quot;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  scope: ”/test/a.html&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fetch(‘/test/a.html’).then(function(response) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return response.text();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;).then(function(text) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(text); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 demo.html 文件中，我们看到，将 /test/a.html 的请求交给 worker.js 来处理，处理方式为：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// workker.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;addEventListener(&lt;span class=&quot;string&quot;&gt;&quot;fetch&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;evt&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  evt.respondWith(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Response(“Hi, Barret Lee”));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 demo.html 的回调中使用 Fetch 获取/test/a.html 这个并不存在的内容，被 ServiceWorker 捕获，交给 worker.js 处理并响应 Hi, Barret Lee 的文本，整个设计思路十分清晰，很轻松地拦截了来自客户端的请求，并作出了响应。&lt;/p&gt;
&lt;p&gt;由于 ServiceWorker 是对 Promise 友好的，响应时也可以模拟服务器休眠状态：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;addEventListener(&lt;span class=&quot;string&quot;&gt;&quot;fetch&quot;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;evt&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  evt.respondWith(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resolve(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Response(“Hi, Barret Lee”));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于 Fetch API 提供了对 Header 头的修改，我们几乎可以利用 ServiceWorker 实现真实 HTTP Server 的基本功能。&lt;/p&gt;
&lt;p&gt;ServiceWorker 一定程度上改变了 Web 协作的交互模式，传统情况下，我们需要开启一个 Web Server，或者让其他人提供 HTTP Server，前后端之间交互，沟通成本比较高。而 ServiceWorker 把 HTTP Server 搬到了客户端，我们可以在浏览器上轻松 Hold 住两端的操作。这也算是 Web 技术栈融合的表现吧。&lt;/p&gt;
&lt;p&gt;当我们的目光放在 HTTP 的交互上，ServiceWorker 会有无限的想象空间，比如对 History API 的延伸思考，跨页面共享问题，前端请求合并和分拆问题，mock 数据问题，前后端的联调问题，类 graphQL 问题，数据的缓存更新和复用问题等等。&lt;/p&gt;
&lt;h3 id=&quot;Cache-API&quot;&gt;&lt;a href=&quot;#Cache-API&quot; class=&quot;headerlink&quot; title=&quot;Cache API&quot;&gt;&lt;/a&gt;Cache API&lt;/h3&gt;&lt;p&gt;Cache API，简而言之就是一个 Request/Response 的缓存对象组，它的生命周期跟 ServiceWorker 是紧密相连的，它没有失效时间，不删除就会一直保持原样。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;caches.open(&lt;span class=&quot;string&quot;&gt;&#39;test-cache&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cache&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cache.add(&lt;span class=&quot;string&quot;&gt;&#39;/index.html&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个简单的操作，就将 /index.html 这个页面缓存了下来，如果你使用的是最新版的 Chrome，可以打开 DevTools &amp;gt; Resources &amp;gt; Cache Storage，多了一个 test-cache 的缓存表，表中多出一项，Request 为 &lt;a href=&quot;http://barretlee.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://barretlee.com/index.html&lt;/a&gt;, Response 为 OK。如下方式可以查看缓存内容：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;caches.open(&lt;span class=&quot;string&quot;&gt;&#39;test-cache&#39;&lt;/span&gt;).then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cache&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cache.keys().then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;cachedRequests&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(cachedRequests);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当浏览器处于 idle（空闲） 状态的时候，会将 Cache 资源预加载到本地。这也让我想起了 link 标签中有一个 prefetch 功能，也会有同学想到 Manifest，不过这两个东西都是不能友好控制的，而 Cache 给我们带来了这样的便利。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h3&gt;&lt;p&gt;我一直相当看好 Fetch API 系列相关的新接口，它的特点也很清晰，首先是基于 Promise 的实现，这个实现解决了回调和状态控制的问题，然后是提供了应用级别的接口访问，现在可以把一个 HTTP 请求作为可控的对象随意操作，无论是 Request 还是 Response 都在我们的掌握之中，同时也一定程度解决了跨页面资源共享的问题（至于跨页面通讯，我们有 postMessage 和 MessageChannel 等工具）。&lt;/p&gt;
&lt;p&gt;目前浏览器对 Fetch API 和 ServiceWorker 的支持都是比较可观的，虽然 W3C 上的文档状态还是 Draft 模式，相信随着我们对业务需求的更加明确，对前端认知的的不断深入，这些东西将很快被定为 RFC。&lt;/p&gt;
&lt;p&gt;本文没有对 API 的使用做深入的说明，一方面是因为这些东西能在 Google 上找到，其次，我觉得有些 API 的设计上还不够成熟，今后会有增删，感兴趣的同学可以去 W3C 提供的文档中深入学习下。&lt;/p&gt;
&lt;h3 id=&quot;拓展阅读&quot;&gt;&lt;a href=&quot;#拓展阅读&quot; class=&quot;headerlink&quot; title=&quot;拓展阅读&quot;&gt;&lt;/a&gt;拓展阅读&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/file/xhr2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.html5rocks.com/zh/tutorials/file/xhr2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.web-tinker.com/article/20882.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.web-tinker.com/article/20882.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://davidwalsh.name/fetch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://davidwalsh.name/fetch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Cache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Cache&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.barretlee.com/blog/2016/02/16/when-fe-has-the-power-of-server/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http
    
    </summary>
    
      <category term="share" scheme="http://sinaad.github.io/xfe/categories/share/"/>
    
    
      <category term="ServiceWorker" scheme="http://sinaad.github.io/xfe/tags/ServiceWorker/"/>
    
      <category term="js" scheme="http://sinaad.github.io/xfe/tags/js/"/>
    
      <category term="server" scheme="http://sinaad.github.io/xfe/tags/server/"/>
    
  </entry>
  
</feed>
